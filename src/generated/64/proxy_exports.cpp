// Auto-generated source file
#include <cstring>
#include <dlfcn.h>
#include <mutex>

#include <polyhook2/MemProtector.hpp>

#include <koalabox/lib.hpp>
#include <koalabox/logger.hpp>
#include <koalabox/util.hpp>

#include "proxy_exports.hpp"

#define EXPORT extern "C" __attribute__((visibility("default"))) __attribute__((naked))

EXPORT void CAddAppDependencyResult_t_RemoveCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CAddAppDependencyResult_t_SetCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CAddUGCDependencyResult_t_RemoveCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CAddUGCDependencyResult_t_SetCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CAssociateWithClanResult_t_RemoveCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CAssociateWithClanResult_t_SetCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CChangeNumOpenSlotsCallback_t_RemoveCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CChangeNumOpenSlotsCallback_t_SetCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CCheckFileSignature_t_RemoveCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CCheckFileSignature_t_SetCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CClanOfficerListResponse_t_RemoveCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CClanOfficerListResponse_t_SetCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CComputeNewPlayerCompatibilityResult_t_RemoveCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CComputeNewPlayerCompatibilityResult_t_SetCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CCreateBeaconCallback_t_RemoveCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CCreateBeaconCallback_t_SetCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CCreateItemResult_t_RemoveCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CCreateItemResult_t_SetCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CDeleteItemResult_t_RemoveCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CDeleteItemResult_t_SetCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CDurationControl_t_RemoveCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CDurationControl_t_SetCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CEncryptedAppTicketResponse_t_RemoveCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CEncryptedAppTicketResponse_t_SetCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CFileDetailsResult_t_RemoveCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CFileDetailsResult_t_SetCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CFriendsEnumerateFollowingList_t_RemoveCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CFriendsEnumerateFollowingList_t_SetCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CFriendsGetFollowerCount_t_RemoveCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CFriendsGetFollowerCount_t_SetCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CFriendsIsFollowing_t_RemoveCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CFriendsIsFollowing_t_SetCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CGSReputation_t_RemoveCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CGSReputation_t_SetCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CGSStatsReceived_t_RemoveCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CGSStatsReceived_t_SetCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CGSStatsStored_t_RemoveCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CGSStatsStored_t_SetCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CGetAppDependenciesResult_t_RemoveCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CGetAppDependenciesResult_t_SetCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CGetOPFSettingsResult_t_RemoveCallback() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CGetOPFSettingsResult_t_SetCallback() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CGetUserItemVoteResult_t_RemoveCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CGetUserItemVoteResult_t_SetCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CGlobalAchievementPercentagesReady_t_RemoveCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CGlobalAchievementPercentagesReady_t_SetCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CGlobalStatsReceived_t_RemoveCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CGlobalStatsReceived_t_SetCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CHTML_BrowserReady_t_RemoveCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CHTML_BrowserReady_t_SetCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CJoinClanChatRoomCompletionResult_t_RemoveCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CJoinClanChatRoomCompletionResult_t_SetCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CJoinPartyCallback_t_RemoveCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CJoinPartyCallback_t_SetCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CLeaderboardFindResult_t_RemoveCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CLeaderboardFindResult_t_SetCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CLeaderboardScoreUploaded_t_RemoveCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CLeaderboardScoreUploaded_t_SetCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CLeaderboardScoresDownloaded_t_RemoveCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CLeaderboardScoresDownloaded_t_SetCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CLeaderboardUGCSet_t_RemoveCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CLeaderboardUGCSet_t_SetCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CLobbyCreated_t_RemoveCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CLobbyCreated_t_SetCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CLobbyEnter_t_RemoveCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CLobbyEnter_t_SetCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CLobbyMatchList_t_RemoveCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CLobbyMatchList_t_SetCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CMarketEligibilityResponse_t_RemoveCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CMarketEligibilityResponse_t_SetCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CNumberOfCurrentPlayers_t_RemoveCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CNumberOfCurrentPlayers_t_SetCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CPublisherOwnedAppDataReady_t_RemoveCallback() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CPublisherOwnedAppDataReady_t_SetCallback() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CRemoteStorageDeletePublishedFileResult_t_RemoveCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CRemoteStorageDeletePublishedFileResult_t_SetCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CRemoteStorageDownloadUGCResult_t_RemoveCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CRemoteStorageDownloadUGCResult_t_SetCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CRemoteStorageEnumeratePublishedFilesByUserActionResult_t_RemoveCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CRemoteStorageEnumeratePublishedFilesByUserActionResult_t_SetCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CRemoteStorageEnumerateUserPublishedFilesResult_t_RemoveCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CRemoteStorageEnumerateUserPublishedFilesResult_t_SetCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CRemoteStorageEnumerateUserSubscribedFilesResult_t_RemoveCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CRemoteStorageEnumerateUserSubscribedFilesResult_t_SetCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CRemoteStorageEnumerateWorkshopFilesResult_t_RemoveCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CRemoteStorageEnumerateWorkshopFilesResult_t_SetCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CRemoteStorageFileReadAsyncComplete_t_RemoveCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CRemoteStorageFileReadAsyncComplete_t_SetCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CRemoteStorageFileShareResult_t_RemoveCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CRemoteStorageFileShareResult_t_SetCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CRemoteStorageFileWriteAsyncComplete_t_RemoveCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CRemoteStorageFileWriteAsyncComplete_t_SetCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CRemoteStorageGetPublishedFileDetailsResult_t_RemoveCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CRemoteStorageGetPublishedFileDetailsResult_t_SetCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CRemoteStorageGetPublishedItemVoteDetailsResult_t_RemoveCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CRemoteStorageGetPublishedItemVoteDetailsResult_t_SetCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CRemoteStoragePublishFileProgress_t_RemoveCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CRemoteStoragePublishFileProgress_t_SetCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CRemoteStorageSetUserPublishedFileActionResult_t_RemoveCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CRemoteStorageSetUserPublishedFileActionResult_t_SetCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CRemoteStorageSubscribePublishedFileResult_t_RemoveCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CRemoteStorageSubscribePublishedFileResult_t_SetCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CRemoteStorageUnsubscribePublishedFileResult_t_RemoveCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CRemoteStorageUnsubscribePublishedFileResult_t_SetCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CRemoteStorageUpdatePublishedFileResult_t_RemoveCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CRemoteStorageUpdatePublishedFileResult_t_SetCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CRemoteStorageUpdateUserPublishedItemVoteResult_t_RemoveCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CRemoteStorageUpdateUserPublishedItemVoteResult_t_SetCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CRemoveAppDependencyResult_t_RemoveCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CRemoveAppDependencyResult_t_SetCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CRemoveUGCDependencyResult_t_RemoveCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CRemoveUGCDependencyResult_t_SetCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CSetPersonaNameResponse_t_RemoveCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CSetPersonaNameResponse_t_SetCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CSetUserItemVoteResult_t_RemoveCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CSetUserItemVoteResult_t_SetCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CStartPlaytimeTrackingResult_t_RemoveCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CStartPlaytimeTrackingResult_t_SetCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CSteamInventoryEligiblePromoItemDefIDs_t_RemoveCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CSteamInventoryEligiblePromoItemDefIDs_t_SetCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CSteamInventoryRequestPricesResult_t_RemoveCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CSteamInventoryRequestPricesResult_t_SetCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CSteamInventoryStartPurchaseResult_t_RemoveCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CSteamInventoryStartPurchaseResult_t_SetCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CSteamUGCQueryCompleted_t_RemoveCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CSteamUGCQueryCompleted_t_SetCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CStopPlaytimeTrackingResult_t_RemoveCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CStopPlaytimeTrackingResult_t_SetCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CStoreAuthURLResponse_t_RemoveCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CStoreAuthURLResponse_t_SetCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CSubmitItemUpdateResult_t_RemoveCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CSubmitItemUpdateResult_t_SetCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CUserFavoriteItemsListChanged_t_RemoveCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CUserFavoriteItemsListChanged_t_SetCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CUserStatsReceived_t_RemoveCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CUserStatsReceived_t_RemoveCallback() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CUserStatsReceived_t_SetCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void CUserStatsReceived_t_SetCallback() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void GetHSteamPipe() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void GetHSteamUser() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_GetHSteamPipe() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_GetHSteamUser() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_GetSteamInstallPath() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamAppList_GetAppBuildId() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamAppList_GetAppInstallDir() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamAppList_GetAppName() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamAppList_GetInstalledApps() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamAppList_GetNumInstalledApps() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamApps_BGetDLCDataByIndex() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamApps_BIsAppInstalled() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamApps_BIsCybercafe() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamApps_BIsDlcInstalled() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamApps_BIsLowViolence() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamApps_BIsSubscribed() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamApps_BIsSubscribedApp() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamApps_BIsSubscribedFromFamilySharing() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamApps_BIsSubscribedFromFreeWeekend() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamApps_BIsTimedTrial() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamApps_BIsVACBanned() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamApps_GetAppBuildId() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamApps_GetAppInstallDir() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamApps_GetAppOwner() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamApps_GetAvailableGameLanguages() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamApps_GetBetaInfo() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamApps_GetCurrentBetaName() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamApps_GetCurrentGameLanguage() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamApps_GetDLCCount() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamApps_GetDlcDownloadProgress() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamApps_GetEarliestPurchaseUnixTime() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamApps_GetFileDetails() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamApps_GetInstalledDepots() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamApps_GetLaunchCommandLine() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamApps_GetLaunchQueryParam() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamApps_GetNumBetas() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamApps_GetPublisherOwnedAppData() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamApps_InstallDLC() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamApps_MarkContentCorrupt() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamApps_RequestAllProofOfPurchaseKeys() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamApps_RequestAppProofOfPurchaseKey() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamApps_RequestPublisherOwnedAppData() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamApps_SetActiveBeta() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamApps_SetDlcContext() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamApps_UninstallDLC() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamClient_BReleaseSteamPipe() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamClient_BShutdownIfAllPipesClosed() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamClient_ConnectToGlobalUser() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamClient_CreateLocalUser() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamClient_CreateSteamPipe() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamClient_GetIPCCallCount() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamClient_GetISteamAppList() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamClient_GetISteamApps() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamClient_GetISteamController() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamClient_GetISteamFriends() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamClient_GetISteamGameSearch() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamClient_GetISteamGameServer() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamClient_GetISteamGameServerStats() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamClient_GetISteamGenericInterface() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamClient_GetISteamHTMLSurface() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamClient_GetISteamHTTP() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamClient_GetISteamInput() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamClient_GetISteamInventory() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamClient_GetISteamMatchmaking() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamClient_GetISteamMatchmakingServers() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamClient_GetISteamMusic() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamClient_GetISteamMusicRemote() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamClient_GetISteamNetworking() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamClient_GetISteamParentalSettings() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamClient_GetISteamParties() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamClient_GetISteamRemotePlay() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamClient_GetISteamRemoteStorage() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamClient_GetISteamScreenshots() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamClient_GetISteamUGC() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamClient_GetISteamUnifiedMessages() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamClient_GetISteamUser() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamClient_GetISteamUserStats() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamClient_GetISteamUtils() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamClient_GetISteamVideo() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamClient_ReleaseUser() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamClient_Remove_SteamAPI_CPostAPIResultInProcess() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamClient_RunFrame() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamClient_SetLocalIPBinding() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamClient_SetWarningMessageHook() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamClient_Set_SteamAPI_CCheckCallbackRegisteredInProcess() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamClient_Set_SteamAPI_CPostAPIResultInProcess() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamController_ActivateActionSet() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamController_ActivateActionSetLayer() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamController_DeactivateActionSetLayer() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamController_DeactivateAllActionSetLayers() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamController_GetActionOriginFromXboxOrigin() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamController_GetActionSetHandle() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamController_GetActiveActionSetLayers() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamController_GetAnalogActionData() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamController_GetAnalogActionHandle() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamController_GetAnalogActionOrigins() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamController_GetConnectedControllers() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamController_GetControllerBindingRevision() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamController_GetControllerForGamepadIndex() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamController_GetControllerState() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamController_GetCurrentActionSet() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamController_GetDigitalActionData() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamController_GetDigitalActionHandle() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamController_GetDigitalActionOrigins() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamController_GetGamepadIndexForController() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamController_GetGlyphForActionOrigin() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamController_GetGlyphForXboxOrigin() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamController_GetInputTypeForHandle() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamController_GetMotionData() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamController_GetStringForActionOrigin() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamController_GetStringForXboxOrigin() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamController_Init() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamController_RunFrame() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamController_SetLEDColor() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamController_SetOverrideMode() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamController_ShowAnalogActionOrigins() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamController_ShowBindingPanel() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamController_ShowDigitalActionOrigins() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamController_Shutdown() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamController_StopAnalogActionMomentum() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamController_TranslateActionOrigin() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamController_TriggerHapticPulse() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamController_TriggerRepeatedHapticPulse() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamController_TriggerVibration() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamFriends_ActivateGameOverlay() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamFriends_ActivateGameOverlayInviteDialog() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamFriends_ActivateGameOverlayInviteDialogConnectString() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamFriends_ActivateGameOverlayRemotePlayTogetherInviteDialog() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamFriends_ActivateGameOverlayToStore() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamFriends_ActivateGameOverlayToUser() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamFriends_ActivateGameOverlayToWebPage() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamFriends_BHasEquippedProfileItem() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamFriends_ClearRichPresence() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamFriends_CloseClanChatWindowInSteam() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamFriends_DownloadClanActivityCounts() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamFriends_EnumerateFollowingList() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamFriends_GetChatMemberByIndex() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamFriends_GetClanActivityCounts() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamFriends_GetClanByIndex() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamFriends_GetClanChatMemberCount() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamFriends_GetClanChatMessage() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamFriends_GetClanCount() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamFriends_GetClanName() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamFriends_GetClanOfficerByIndex() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamFriends_GetClanOfficerCount() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamFriends_GetClanOwner() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamFriends_GetClanTag() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamFriends_GetCoplayFriend() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamFriends_GetCoplayFriendCount() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamFriends_GetFollowerCount() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamFriends_GetFriendByIndex() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamFriends_GetFriendCoplayGame() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamFriends_GetFriendCoplayTime() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamFriends_GetFriendCount() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamFriends_GetFriendCountFromSource() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamFriends_GetFriendFromSourceByIndex() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamFriends_GetFriendGamePlayed() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamFriends_GetFriendMessage() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamFriends_GetFriendPersonaName() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamFriends_GetFriendPersonaNameHistory() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamFriends_GetFriendPersonaState() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamFriends_GetFriendRelationship() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamFriends_GetFriendRichPresence() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamFriends_GetFriendRichPresenceKeyByIndex() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamFriends_GetFriendRichPresenceKeyCount() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamFriends_GetFriendSteamLevel() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamFriends_GetFriendsGroupCount() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamFriends_GetFriendsGroupIDByIndex() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamFriends_GetFriendsGroupMembersCount() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamFriends_GetFriendsGroupMembersList() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamFriends_GetFriendsGroupName() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamFriends_GetLargeFriendAvatar() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamFriends_GetMediumFriendAvatar() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamFriends_GetNumChatsWithUnreadPriorityMessages() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamFriends_GetPersonaName() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamFriends_GetPersonaState() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamFriends_GetPlayerNickname() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamFriends_GetProfileItemPropertyString() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamFriends_GetProfileItemPropertyUint() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamFriends_GetSmallFriendAvatar() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamFriends_GetUserRestrictions() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamFriends_HasFriend() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamFriends_InviteUserToGame() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamFriends_IsClanChatAdmin() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamFriends_IsClanChatWindowOpenInSteam() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamFriends_IsClanOfficialGameGroup() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamFriends_IsClanPublic() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamFriends_IsFollowing() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamFriends_IsUserInSource() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamFriends_JoinClanChatRoom() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamFriends_LeaveClanChatRoom() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamFriends_OpenClanChatWindowInSteam() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamFriends_RegisterProtocolInOverlayBrowser() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamFriends_ReplyToFriendMessage() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamFriends_RequestClanOfficerList() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamFriends_RequestEquippedProfileItems() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamFriends_RequestFriendRichPresence() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamFriends_RequestUserInformation() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamFriends_SendClanChatMessage() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamFriends_SetInGameVoiceSpeaking() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamFriends_SetListenForFriendsMessages() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamFriends_SetPersonaName() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamFriends_SetPlayedWith() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamFriends_SetRichPresence() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamGameSearch_AcceptGame() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamGameSearch_AddGameSearchParams() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamGameSearch_CancelRequestPlayersForGame() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamGameSearch_DeclineGame() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamGameSearch_EndGame() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamGameSearch_EndGameSearch() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamGameSearch_HostConfirmGameStart() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamGameSearch_RequestPlayersForGame() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamGameSearch_RetrieveConnectionDetails() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamGameSearch_SearchForGameSolo() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamGameSearch_SearchForGameWithLobby() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamGameSearch_SetConnectionDetails() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamGameSearch_SetGameHostParams() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamGameSearch_SubmitPlayerResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamGameServerStats_ClearUserAchievement() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamGameServerStats_GetUserAchievement() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamGameServerStats_GetUserStat() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamGameServerStats_GetUserStat0() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamGameServerStats_GetUserStatFloat() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamGameServerStats_GetUserStatInt32() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamGameServerStats_RequestUserStats() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamGameServerStats_SetUserAchievement() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamGameServerStats_SetUserStat() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamGameServerStats_SetUserStat0() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamGameServerStats_SetUserStatFloat() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamGameServerStats_SetUserStatInt32() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamGameServerStats_StoreUserStats() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamGameServerStats_UpdateUserAvgRateStat() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamGameServer_AssociateWithClan() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamGameServer_BLoggedOn() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamGameServer_BSecure() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamGameServer_BUpdateUserData() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamGameServer_BeginAuthSession() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamGameServer_CancelAuthTicket() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamGameServer_ClearAllKeyValues() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamGameServer_ComputeNewPlayerCompatibility() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamGameServer_CreateUnauthenticatedUserConnection() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamGameServer_EnableHeartbeats() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamGameServer_EndAuthSession() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamGameServer_ForceHeartbeat() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamGameServer_GetAuthSessionTicket() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamGameServer_GetGameplayStats() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamGameServer_GetNextOutgoingPacket() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamGameServer_GetPublicIP() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamGameServer_GetServerReputation() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamGameServer_GetSteamID() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamGameServer_HandleIncomingPacket() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamGameServer_InitGameServer() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamGameServer_LogOff() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamGameServer_LogOn() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamGameServer_LogOnAnonymous() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamGameServer_RequestUserGroupStatus() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamGameServer_SendUserConnectAndAuthenticate() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamGameServer_SendUserConnectAndAuthenticate_DEPRECATED() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamGameServer_SendUserDisconnect() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamGameServer_SendUserDisconnect_DEPRECATED() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamGameServer_SetAdvertiseServerActive() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamGameServer_SetBotPlayerCount() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamGameServer_SetDedicatedServer() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamGameServer_SetGameData() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamGameServer_SetGameDescription() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamGameServer_SetGameTags() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamGameServer_SetHeartbeatInterval() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamGameServer_SetKeyValue() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamGameServer_SetMapName() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamGameServer_SetMaxPlayerCount() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamGameServer_SetModDir() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamGameServer_SetPasswordProtected() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamGameServer_SetProduct() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamGameServer_SetRegion() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamGameServer_SetServerName() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamGameServer_SetSpectatorPort() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamGameServer_SetSpectatorServerName() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamGameServer_UserHasLicenseForApp() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamGameServer_WasRestartRequested() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamHTMLSurface_AddHeader() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamHTMLSurface_AllowStartRequest() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamHTMLSurface_CopyToClipboard() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamHTMLSurface_CreateBrowser() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamHTMLSurface_DestructISteamHTMLSurface() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamHTMLSurface_ExecuteJavascript() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamHTMLSurface_FileLoadDialogResponse() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamHTMLSurface_Find() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamHTMLSurface_GetLinkAtPosition() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamHTMLSurface_GoBack() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamHTMLSurface_GoForward() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamHTMLSurface_Init() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamHTMLSurface_JSDialogResponse() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamHTMLSurface_KeyChar() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamHTMLSurface_KeyDown() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamHTMLSurface_KeyUp() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamHTMLSurface_LoadURL() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamHTMLSurface_MouseDoubleClick() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamHTMLSurface_MouseDown() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamHTMLSurface_MouseMove() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamHTMLSurface_MouseUp() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamHTMLSurface_MouseWheel() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamHTMLSurface_OpenDeveloperTools() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamHTMLSurface_PasteFromClipboard() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamHTMLSurface_Reload() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamHTMLSurface_RemoveBrowser() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamHTMLSurface_SetBackgroundMode() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamHTMLSurface_SetCookie() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamHTMLSurface_SetDPIScalingFactor() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamHTMLSurface_SetHorizontalScroll() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamHTMLSurface_SetKeyFocus() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamHTMLSurface_SetPageScaleFactor() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamHTMLSurface_SetSize() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamHTMLSurface_SetVerticalScroll() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamHTMLSurface_Shutdown() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamHTMLSurface_StopFind() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamHTMLSurface_StopLoad() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamHTMLSurface_ViewSource() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamHTTP_CreateCookieContainer() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamHTTP_CreateHTTPRequest() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamHTTP_DeferHTTPRequest() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamHTTP_GetHTTPDownloadProgressPct() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamHTTP_GetHTTPRequestWasTimedOut() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamHTTP_GetHTTPResponseBodyData() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamHTTP_GetHTTPResponseBodySize() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamHTTP_GetHTTPResponseHeaderSize() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamHTTP_GetHTTPResponseHeaderValue() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamHTTP_GetHTTPStreamingResponseBodyData() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamHTTP_PrioritizeHTTPRequest() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamHTTP_ReleaseCookieContainer() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamHTTP_ReleaseHTTPRequest() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamHTTP_SendHTTPRequest() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamHTTP_SendHTTPRequestAndStreamResponse() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamHTTP_SetCookie() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamHTTP_SetHTTPRequestAbsoluteTimeoutMS() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamHTTP_SetHTTPRequestContextValue() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamHTTP_SetHTTPRequestCookieContainer() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamHTTP_SetHTTPRequestGetOrPostParameter() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamHTTP_SetHTTPRequestHeaderValue() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamHTTP_SetHTTPRequestNetworkActivityTimeout() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamHTTP_SetHTTPRequestRawPostBody() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamHTTP_SetHTTPRequestRequiresVerifiedCertificate() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamHTTP_SetHTTPRequestUserAgentInfo() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInput_ActivateActionSet() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInput_ActivateActionSetLayer() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInput_BNewDataAvailable() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInput_BWaitForData() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInput_DeactivateActionSetLayer() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInput_DeactivateAllActionSetLayers() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInput_EnableActionEventCallbacks() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInput_EnableDeviceCallbacks() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInput_GetActionOriginFromXboxOrigin() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInput_GetActionSetHandle() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInput_GetActiveActionSetLayers() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInput_GetAnalogActionData() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInput_GetAnalogActionHandle() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInput_GetAnalogActionOrigins() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInput_GetConnectedControllers() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInput_GetControllerForGamepadIndex() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInput_GetCurrentActionSet() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInput_GetDeviceBindingRevision() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInput_GetDigitalActionData() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInput_GetDigitalActionHandle() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInput_GetDigitalActionOrigins() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInput_GetGamepadIndexForController() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInput_GetGlyphForActionOrigin() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInput_GetGlyphForActionOrigin_Legacy() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInput_GetGlyphForXboxOrigin() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInput_GetGlyphPNGForActionOrigin() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInput_GetGlyphSVGForActionOrigin() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInput_GetInputTypeForHandle() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInput_GetMotionData() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInput_GetRemotePlaySessionID() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInput_GetSessionInputConfigurationSettings() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInput_GetStringForActionOrigin() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInput_GetStringForAnalogActionName() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInput_GetStringForDigitalActionName() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInput_GetStringForXboxOrigin() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInput_Init() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInput_Legacy_TriggerHapticPulse() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInput_Legacy_TriggerRepeatedHapticPulse() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInput_RunFrame() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInput_SetDualSenseTriggerEffect() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInput_SetInputActionManifestFilePath() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInput_SetLEDColor() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInput_ShowBindingPanel() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInput_Shutdown() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInput_StopAnalogActionMomentum() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInput_TranslateActionOrigin() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInput_TriggerHapticPulse() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInput_TriggerRepeatedHapticPulse() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInput_TriggerSimpleHapticEvent() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInput_TriggerVibration() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInput_TriggerVibrationExtended() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInventory_AddPromoItem() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInventory_AddPromoItems() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInventory_CheckResultSteamID() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInventory_ConsumeItem() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInventory_DeserializeResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInventory_DestroyResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInventory_ExchangeItems() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInventory_GenerateItems() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInventory_GetAllItems() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInventory_GetEligiblePromoItemDefinitionIDs() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInventory_GetItemDefinitionIDs() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInventory_GetItemDefinitionProperty() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInventory_GetItemPrice() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInventory_GetItemsByID() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInventory_GetItemsWithPrices() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInventory_GetNumItemsWithPrices() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInventory_GetResultItemProperty() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInventory_GetResultItems() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInventory_GetResultStatus() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInventory_GetResultTimestamp() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInventory_GrantPromoItems() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInventory_InspectItem() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInventory_LoadItemDefinitions() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInventory_RemoveProperty() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInventory_RequestEligiblePromoItemDefinitionsIDs() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInventory_RequestPrices() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInventory_SendItemDropHeartbeat() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInventory_SerializeResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInventory_SetProperty() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInventory_SetProperty0() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInventory_SetProperty1() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInventory_SetProperty2() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInventory_SetPropertyBool() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInventory_SetPropertyFloat() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInventory_SetPropertyInt64() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInventory_SetPropertyString() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInventory_StartPurchase() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInventory_StartUpdateProperties() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInventory_SubmitUpdateProperties() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInventory_TradeItems() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInventory_TransferItemQuantity() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamInventory_TriggerItemDrop() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMatchmakingPingResponse_ServerFailedToRespond() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMatchmakingPingResponse_ServerResponded() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMatchmakingPlayersResponse_AddPlayerToList() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMatchmakingPlayersResponse_PlayersFailedToRespond() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMatchmakingPlayersResponse_PlayersRefreshComplete() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMatchmakingRulesResponse_RulesFailedToRespond() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMatchmakingRulesResponse_RulesRefreshComplete() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMatchmakingRulesResponse_RulesResponded() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMatchmakingServerListResponse_RefreshComplete() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMatchmakingServerListResponse_ServerFailedToRespond() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMatchmakingServerListResponse_ServerResponded() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMatchmakingServers_CancelQuery() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMatchmakingServers_CancelServerQuery() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMatchmakingServers_GetServerCount() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMatchmakingServers_GetServerDetails() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMatchmakingServers_IsRefreshing() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMatchmakingServers_PingServer() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMatchmakingServers_PlayerDetails() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMatchmakingServers_RefreshQuery() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMatchmakingServers_RefreshServer() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMatchmakingServers_ReleaseRequest() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMatchmakingServers_RequestFavoritesServerList() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMatchmakingServers_RequestFriendsServerList() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMatchmakingServers_RequestHistoryServerList() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMatchmakingServers_RequestInternetServerList() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMatchmakingServers_RequestLANServerList() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMatchmakingServers_RequestSpectatorServerList() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMatchmakingServers_ServerRules() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMatchmaking_AddFavoriteGame() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMatchmaking_AddRequestLobbyListCompatibleMembersFilter() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMatchmaking_AddRequestLobbyListDistanceFilter() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMatchmaking_AddRequestLobbyListFilterSlotsAvailable() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMatchmaking_AddRequestLobbyListNearValueFilter() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMatchmaking_AddRequestLobbyListNumericalFilter() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMatchmaking_AddRequestLobbyListResultCountFilter() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMatchmaking_AddRequestLobbyListStringFilter() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMatchmaking_CreateLobby() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMatchmaking_DeleteLobbyData() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMatchmaking_GetFavoriteGame() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMatchmaking_GetFavoriteGameCount() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMatchmaking_GetLobbyByIndex() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMatchmaking_GetLobbyChatEntry() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMatchmaking_GetLobbyData() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMatchmaking_GetLobbyDataByIndex() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMatchmaking_GetLobbyDataCount() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMatchmaking_GetLobbyGameServer() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMatchmaking_GetLobbyMemberByIndex() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMatchmaking_GetLobbyMemberData() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMatchmaking_GetLobbyMemberLimit() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMatchmaking_GetLobbyOwner() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMatchmaking_GetNumLobbyMembers() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMatchmaking_InviteUserToLobby() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMatchmaking_JoinLobby() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMatchmaking_LeaveLobby() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMatchmaking_RemoveFavoriteGame() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMatchmaking_RequestLobbyData() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMatchmaking_RequestLobbyList() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMatchmaking_SendLobbyChatMsg() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMatchmaking_SetLinkedLobby() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMatchmaking_SetLobbyData() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMatchmaking_SetLobbyGameServer() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMatchmaking_SetLobbyJoinable() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMatchmaking_SetLobbyMemberData() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMatchmaking_SetLobbyMemberLimit() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMatchmaking_SetLobbyOwner() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMatchmaking_SetLobbyType() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMusicRemote_BActivationSuccess() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMusicRemote_BIsCurrentMusicRemote() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMusicRemote_CurrentEntryDidChange() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMusicRemote_CurrentEntryIsAvailable() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMusicRemote_CurrentEntryWillChange() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMusicRemote_DeregisterSteamMusicRemote() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMusicRemote_EnableLooped() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMusicRemote_EnablePlayNext() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMusicRemote_EnablePlayPrevious() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMusicRemote_EnablePlaylists() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMusicRemote_EnableQueue() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMusicRemote_EnableShuffled() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMusicRemote_PlaylistDidChange() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMusicRemote_PlaylistWillChange() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMusicRemote_QueueDidChange() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMusicRemote_QueueWillChange() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMusicRemote_RegisterSteamMusicRemote() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMusicRemote_ResetPlaylistEntries() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMusicRemote_ResetQueueEntries() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMusicRemote_SetCurrentPlaylistEntry() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMusicRemote_SetCurrentQueueEntry() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMusicRemote_SetDisplayName() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMusicRemote_SetPNGIcon_64x64() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMusicRemote_SetPlaylistEntry() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMusicRemote_SetQueueEntry() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMusicRemote_UpdateCurrentEntryCoverArt() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMusicRemote_UpdateCurrentEntryElapsedSeconds() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMusicRemote_UpdateCurrentEntryText() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMusicRemote_UpdateLooped() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMusicRemote_UpdatePlaybackStatus() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMusicRemote_UpdateShuffled() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMusicRemote_UpdateVolume() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMusic_BIsEnabled() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMusic_BIsPlaying() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMusic_GetPlaybackStatus() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMusic_GetVolume() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMusic_Pause() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMusic_Play() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMusic_PlayNext() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMusic_PlayPrevious() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamMusic_SetVolume() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingConnectionCustomSignaling_Release() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingConnectionCustomSignaling_SendSignal() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingCustomSignalingRecvContext_OnConnectRequest() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingCustomSignalingRecvContext_SendRejectionSignal() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingFakeUDPPort_DestroyFakeUDPPort() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingFakeUDPPort_ReceiveMessages() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingFakeUDPPort_ScheduleCleanup() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingFakeUDPPort_SendMessageToFakeIP() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingMessages_AcceptSessionWithUser() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingMessages_CloseChannelWithUser() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingMessages_CloseSessionWithUser() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingMessages_GetSessionConnectionInfo() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingMessages_ReceiveMessagesOnChannel() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingMessages_SendMessageToUser() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_AcceptConnection() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_BeginAsyncRequestFakeIP() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_CloseConnection() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_CloseListenSocket() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_ConfigureConnectionLanes() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_ConnectByIPAddress() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_ConnectP2P() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_ConnectP2PCustomSignaling() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_ConnectToHostedDedicatedServer() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_CreateFakeUDPPort() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_CreateHostedDedicatedServerListenSocket() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_CreateListenSocketIP() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_CreateListenSocketP2P() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_CreateListenSocketP2PFakeIP() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_CreatePollGroup() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_CreateSocketPair() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_DestroyPollGroup() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_FindRelayAuthTicketForServer() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_FlushMessagesOnConnection() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_GetAuthenticationStatus() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_GetCertificateRequest() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_GetConnectionInfo() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_GetConnectionName() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_GetConnectionRealTimeStatus() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_GetConnectionUserData() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_GetDetailedConnectionStatus() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_GetFakeIP() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_GetGameCoordinatorServerLogin() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_GetHostedDedicatedServerAddress() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_GetHostedDedicatedServerPOPID() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_GetHostedDedicatedServerPort() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_GetIdentity() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_GetListenSocketAddress() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_GetQuickConnectionStatus() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_GetRemoteFakeIPForConnection() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_InitAuthentication() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_ReceiveMessagesOnConnection() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_ReceiveMessagesOnPollGroup() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_ReceivedP2PCustomSignal() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_ReceivedRelayAuthTicket() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_ResetIdentity() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_RunCallbacks() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_SendMessageToConnection() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_SendMessages() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_SetCertificate() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_SetConnectionName() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_SetConnectionPollGroup() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_SetConnectionUserData() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingUtils_AllocateMessage() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingUtils_CheckPingDataUpToDate() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingUtils_ConvertPingLocationToString() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingUtils_EstimatePingTimeBetweenTwoLocations() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingUtils_EstimatePingTimeFromLocalHost() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingUtils_GetConfigValue() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingUtils_GetConfigValueInfo() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingUtils_GetDirectPingToPOP() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingUtils_GetFirstConfigValue() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingUtils_GetIPv4FakeIPType() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingUtils_GetLocalPingLocation() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingUtils_GetLocalTimestamp() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingUtils_GetPOPCount() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingUtils_GetPOPList() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingUtils_GetPingToDataCenter() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingUtils_GetRealIdentityForFakeIP() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingUtils_GetRelayNetworkStatus() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingUtils_InitRelayNetworkAccess() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingUtils_IsFakeIPv4() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingUtils_IterateGenericEditableConfigValues() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingUtils_ParsePingLocationString() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingUtils_SetConfigValue() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingUtils_SetConfigValueStruct() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingUtils_SetConnectionConfigValueFloat() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingUtils_SetConnectionConfigValueInt32() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingUtils_SetConnectionConfigValueString() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingUtils_SetDebugOutputFunction() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingUtils_SetGlobalCallback_FakeIPResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingUtils_SetGlobalCallback_MessagesSessionFailed() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingUtils_SetGlobalCallback_MessagesSessionRequest() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingUtils_SetGlobalCallback_SteamNetAuthenticationStatusChanged() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingUtils_SetGlobalCallback_SteamNetConnectionStatusChanged() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingUtils_SetGlobalCallback_SteamRelayNetworkStatusChanged() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingUtils_SetGlobalConfigValueFloat() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingUtils_SetGlobalConfigValueInt32() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingUtils_SetGlobalConfigValuePtr() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingUtils_SetGlobalConfigValueString() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingUtils_SteamNetworkingIPAddr_GetFakeIPType() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingUtils_SteamNetworkingIPAddr_ParseString() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingUtils_SteamNetworkingIPAddr_ToString() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingUtils_SteamNetworkingIdentity_ParseString() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworkingUtils_SteamNetworkingIdentity_ToString() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworking_AcceptP2PSessionWithUser() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworking_AllowP2PPacketRelay() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworking_CloseP2PChannelWithUser() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworking_CloseP2PSessionWithUser() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworking_CreateConnectionSocket() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworking_CreateListenSocket() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworking_CreateP2PConnectionSocket() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworking_DestroyListenSocket() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworking_DestroySocket() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworking_GetListenSocketInfo() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworking_GetMaxPacketSize() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworking_GetP2PSessionState() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworking_GetSocketConnectionType() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworking_GetSocketInfo() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworking_IsDataAvailable() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworking_IsDataAvailableOnSocket() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworking_IsP2PPacketAvailable() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworking_ReadP2PPacket() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworking_RetrieveData() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworking_RetrieveDataFromSocket() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworking_SendDataOnSocket() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamNetworking_SendP2PPacket() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamParentalSettings_BIsAppBlocked() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamParentalSettings_BIsAppInBlockList() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamParentalSettings_BIsFeatureBlocked() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamParentalSettings_BIsFeatureInBlockList() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamParentalSettings_BIsParentalLockEnabled() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamParentalSettings_BIsParentalLockLocked() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamParties_CancelReservation() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamParties_ChangeNumOpenSlots() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamParties_CreateBeacon() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamParties_DestroyBeacon() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamParties_GetAvailableBeaconLocations() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamParties_GetBeaconByIndex() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamParties_GetBeaconDetails() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamParties_GetBeaconLocationData() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamParties_GetNumActiveBeacons() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamParties_GetNumAvailableBeaconLocations() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamParties_JoinParty() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamParties_OnReservationCompleted() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamRemotePlay_BEnableRemotePlayTogetherDirectInput() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamRemotePlay_BGetSessionClientResolution() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamRemotePlay_BSendRemotePlayTogetherInvite() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamRemotePlay_BStartRemotePlayTogether() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamRemotePlay_CreateMouseCursor() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamRemotePlay_DisableRemotePlayTogetherDirectInput() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamRemotePlay_GetInput() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamRemotePlay_GetSessionClientFormFactor() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamRemotePlay_GetSessionClientName() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamRemotePlay_GetSessionCount() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamRemotePlay_GetSessionID() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamRemotePlay_GetSessionSteamID() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamRemotePlay_SetMouseCursor() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamRemotePlay_SetMousePosition() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamRemotePlay_SetMouseVisibility() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamRemotePlay_ShowRemotePlayTogetherUI() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_BeginFileWriteBatch() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_CommitPublishedFileUpdate() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_CreatePublishedFileUpdateRequest() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_DeletePublishedFile() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_EndFileWriteBatch() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_EnumeratePublishedFilesByUserAction() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_EnumeratePublishedWorkshopFiles() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_EnumerateUserPublishedFiles() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_EnumerateUserSharedWorkshopFiles() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_EnumerateUserSubscribedFiles() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_FileDelete() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_FileExists() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_FileForget() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_FilePersisted() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_FileRead() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_FileReadAsync() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_FileReadAsyncComplete() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_FileShare() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_FileWrite() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_FileWriteAsync() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_FileWriteStreamCancel() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_FileWriteStreamClose() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_FileWriteStreamOpen() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_FileWriteStreamWriteChunk() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_GetCachedUGCCount() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_GetCachedUGCHandle() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_GetFileCount() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_GetFileNameAndSize() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_GetFileSize() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_GetFileTimestamp() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_GetLocalFileChange() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_GetLocalFileChangeCount() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_GetPublishedFileDetails() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_GetPublishedItemVoteDetails() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_GetQuota() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_GetSyncPlatforms() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_GetUGCDetails() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_GetUGCDownloadProgress() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_GetUserPublishedItemVoteDetails() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_IsCloudEnabledForAccount() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_IsCloudEnabledForApp() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_PublishVideo() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_PublishWorkshopFile() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_SetCloudEnabledForApp() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_SetSyncPlatforms() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_SetUserPublishedFileAction() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_SubscribePublishedFile() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_UGCDownload() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_UGCDownloadToLocation() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_UGCRead() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_UnsubscribePublishedFile() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_UpdatePublishedFileDescription() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_UpdatePublishedFileFile() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_UpdatePublishedFilePreviewFile() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_UpdatePublishedFileSetChangeDescription() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_UpdatePublishedFileTags() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_UpdatePublishedFileTitle() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_UpdatePublishedFileVisibility() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_UpdateUserPublishedItemVote() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamScreenshots_AddScreenshotToLibrary() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamScreenshots_AddVRScreenshotToLibrary() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamScreenshots_HookScreenshots() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamScreenshots_IsScreenshotsHooked() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamScreenshots_SetLocation() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamScreenshots_TagPublishedFile() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamScreenshots_TagUser() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamScreenshots_TriggerScreenshot() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamScreenshots_WriteScreenshot() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamTV_AddBroadcastGameData() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamTV_AddRegion() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamTV_AddTimelineMarker() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamTV_IsBroadcasting() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamTV_RemoveBroadcastGameData() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamTV_RemoveRegion() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamTV_RemoveTimelineMarker() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamTimeline_AddGamePhaseTag() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamTimeline_AddInstantaneousTimelineEvent() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamTimeline_AddRangeTimelineEvent() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamTimeline_AddTimelineEvent() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamTimeline_ClearTimelineStateDescription() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamTimeline_ClearTimelineTooltip() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamTimeline_DoesEventRecordingExist() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamTimeline_DoesGamePhaseRecordingExist() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamTimeline_EndGamePhase() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamTimeline_EndRangeTimelineEvent() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamTimeline_OpenOverlayToGamePhase() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamTimeline_OpenOverlayToTimelineEvent() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamTimeline_RemoveTimelineEvent() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamTimeline_SetGamePhaseAttribute() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamTimeline_SetGamePhaseID() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamTimeline_SetTimelineGameMode() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamTimeline_SetTimelineStateDescription() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamTimeline_SetTimelineTooltip() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamTimeline_StartGamePhase() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamTimeline_StartRangeTimelineEvent() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamTimeline_UpdateRangeTimelineEvent() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_AddAppDependency() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_AddContentDescriptor() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_AddDependency() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_AddExcludedTag() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_AddItemKeyValueTag() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_AddItemPreviewFile() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_AddItemPreviewVideo() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_AddItemToFavorites() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_AddRequiredKeyValueTag() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_AddRequiredTag() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_AddRequiredTagGroup() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_BInitWorkshopForGameServer() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_CreateItem() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_CreateQueryAllUGCRequest() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_CreateQueryAllUGCRequest0() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_CreateQueryAllUGCRequestCursor() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_CreateQueryAllUGCRequestPage() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_CreateQueryUGCDetailsRequest() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_CreateQueryUserUGCRequest() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_DeleteItem() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_DownloadItem() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_GetAppDependencies() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_GetItemDownloadInfo() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_GetItemInstallInfo() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_GetItemState() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_GetItemUpdateProgress() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_GetNumSubscribedItems() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_GetNumSupportedGameVersions() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_GetQueryFirstUGCKeyValueTag() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_GetQueryUGCAdditionalPreview() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_GetQueryUGCChildren() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_GetQueryUGCContentDescriptors() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_GetQueryUGCKeyValueTag() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_GetQueryUGCKeyValueTag0() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_GetQueryUGCMetadata() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_GetQueryUGCNumAdditionalPreviews() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_GetQueryUGCNumKeyValueTags() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_GetQueryUGCNumTags() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_GetQueryUGCPreviewURL() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_GetQueryUGCResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_GetQueryUGCStatistic() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_GetQueryUGCTag() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_GetQueryUGCTagDisplayName() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_GetSubscribedItems() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_GetSupportedGameVersionData() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_GetUserContentDescriptorPreferences() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_GetUserItemVote() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_GetWorkshopEULAStatus() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_ReleaseQueryUGCRequest() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_RemoveAllItemKeyValueTags() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_RemoveAppDependency() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_RemoveContentDescriptor() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_RemoveDependency() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_RemoveItemFromFavorites() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_RemoveItemKeyValueTags() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_RemoveItemPreview() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_RequestUGCDetails() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_SendQueryUGCRequest() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_SetAdminQuery() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_SetAllowCachedResponse() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_SetAllowLegacyUpload() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_SetCloudFileNameFilter() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_SetItemContent() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_SetItemDescription() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_SetItemMetadata() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_SetItemPreview() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_SetItemTags() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_SetItemTitle() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_SetItemUpdateLanguage() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_SetItemVisibility() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_SetItemsDisabledLocally() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_SetLanguage() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_SetMatchAnyTag() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_SetRankedByTrendDays() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_SetRequiredGameVersions() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_SetReturnAdditionalPreviews() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_SetReturnChildren() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_SetReturnKeyValueTags() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_SetReturnLongDescription() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_SetReturnMetadata() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_SetReturnOnlyIDs() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_SetReturnPlaytimeStats() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_SetReturnTotalOnly() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_SetSearchText() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_SetSubscriptionsLoadOrder() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_SetTimeCreatedDateRange() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_SetTimeUpdatedDateRange() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_SetUserItemVote() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_ShowWorkshopEULA() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_StartItemUpdate() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_StartPlaytimeTracking() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_StopPlaytimeTracking() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_StopPlaytimeTrackingForAllItems() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_SubmitItemUpdate() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_SubscribeItem() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_SuspendDownloads() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_UnsubscribeItem() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_UpdateItemPreviewFile() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUGC_UpdateItemPreviewVideo() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUnifiedMessages_GetMethodResponseData() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUnifiedMessages_GetMethodResponseInfo() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUnifiedMessages_ReleaseMethod() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUnifiedMessages_SendMethod() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUnifiedMessages_SendNotification() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUserStats_AttachLeaderboardUGC() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUserStats_ClearAchievement() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUserStats_DownloadLeaderboardEntries() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUserStats_DownloadLeaderboardEntriesForUsers() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUserStats_FindLeaderboard() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUserStats_FindOrCreateLeaderboard() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUserStats_GetAchievement() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUserStats_GetAchievementAchievedPercent() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUserStats_GetAchievementAndUnlockTime() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUserStats_GetAchievementDisplayAttribute() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUserStats_GetAchievementIcon() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUserStats_GetAchievementName() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUserStats_GetAchievementProgressLimitsFloat() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUserStats_GetAchievementProgressLimitsInt32() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUserStats_GetDownloadedLeaderboardEntry() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUserStats_GetGlobalStat() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUserStats_GetGlobalStat0() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUserStats_GetGlobalStatDouble() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUserStats_GetGlobalStatHistory() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUserStats_GetGlobalStatHistory0() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUserStats_GetGlobalStatHistoryDouble() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUserStats_GetGlobalStatHistoryInt64() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUserStats_GetGlobalStatInt64() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUserStats_GetLeaderboardDisplayType() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUserStats_GetLeaderboardEntryCount() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUserStats_GetLeaderboardName() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUserStats_GetLeaderboardSortMethod() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUserStats_GetMostAchievedAchievementInfo() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUserStats_GetNextMostAchievedAchievementInfo() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUserStats_GetNumAchievements() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUserStats_GetNumberOfCurrentPlayers() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUserStats_GetStat() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUserStats_GetStat0() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUserStats_GetStatFloat() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUserStats_GetStatInt32() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUserStats_GetUserAchievement() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUserStats_GetUserAchievementAndUnlockTime() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUserStats_GetUserStat() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUserStats_GetUserStat0() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUserStats_GetUserStatFloat() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUserStats_GetUserStatInt32() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUserStats_IndicateAchievementProgress() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUserStats_RequestCurrentStats() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUserStats_RequestGlobalAchievementPercentages() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUserStats_RequestGlobalStats() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUserStats_RequestUserStats() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUserStats_ResetAllStats() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUserStats_SetAchievement() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUserStats_SetStat() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUserStats_SetStat0() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUserStats_SetStatFloat() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUserStats_SetStatInt32() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUserStats_StoreStats() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUserStats_UpdateAvgRateStat() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUserStats_UploadLeaderboardScore() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUser_AdvertiseGame() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUser_BIsBehindNAT() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUser_BIsPhoneIdentifying() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUser_BIsPhoneRequiringVerification() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUser_BIsPhoneVerified() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUser_BIsTwoFactorEnabled() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUser_BLoggedOn() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUser_BSetDurationControlOnlineState() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUser_BeginAuthSession() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUser_CancelAuthTicket() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUser_DecompressVoice() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUser_EndAuthSession() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUser_GetAuthSessionTicket() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUser_GetAuthTicketForWebApi() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUser_GetAvailableVoice() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUser_GetDurationControl() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUser_GetEncryptedAppTicket() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUser_GetGameBadgeLevel() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUser_GetHSteamUser() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUser_GetMarketEligibility() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUser_GetPlayerSteamLevel() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUser_GetSteamID() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUser_GetUserDataFolder() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUser_GetVoice() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUser_GetVoiceOptimalSampleRate() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUser_InitiateGameConnection() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUser_InitiateGameConnection_DEPRECATED() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUser_RequestEncryptedAppTicket() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUser_RequestStoreAuthURL() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUser_StartVoiceRecording() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUser_StopVoiceRecording() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUser_TerminateGameConnection() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUser_TerminateGameConnection_DEPRECATED() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUser_TrackAppUsageEvent() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUser_UserHasLicenseForApp() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUtils_BOverlayNeedsPresent() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUtils_CheckFileSignature() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUtils_DismissFloatingGamepadTextInput() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUtils_DismissGamepadTextInput() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUtils_FilterText() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUtils_GetAPICallFailureReason() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUtils_GetAPICallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUtils_GetAppID() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUtils_GetCSERIPPort() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUtils_GetConnectedUniverse() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUtils_GetCurrentBatteryPower() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUtils_GetEnteredGamepadTextInput() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUtils_GetEnteredGamepadTextLength() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUtils_GetIPCCallCount() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUtils_GetIPCountry() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUtils_GetIPv6ConnectivityState() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUtils_GetImageRGBA() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUtils_GetImageSize() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUtils_GetSecondsSinceAppActive() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUtils_GetSecondsSinceComputerActive() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUtils_GetServerRealTime() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUtils_GetSteamUILanguage() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUtils_InitFilterText() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUtils_IsAPICallCompleted() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUtils_IsOverlayEnabled() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUtils_IsSteamChinaLauncher() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUtils_IsSteamInBigPictureMode() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUtils_IsSteamRunningInVR() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUtils_IsSteamRunningOnSteamDeck() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUtils_IsVRHeadsetStreamingEnabled() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUtils_RunFrame() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUtils_SetGameLauncherMode() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUtils_SetOverlayNotificationInset() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUtils_SetOverlayNotificationPosition() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUtils_SetVRHeadsetStreamingEnabled() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUtils_SetWarningMessageHook() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUtils_ShowFloatingGamepadTextInput() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUtils_ShowGamepadTextInput() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUtils_ShowModalGamepadTextInput() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamUtils_StartVRDashboard() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamVideo_AddTimelineHighlightMarker() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamVideo_AddTimelineRange() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamVideo_AddTimelineRangeEnd() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamVideo_AddTimelineRangeStart() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamVideo_AddTimelineTimestamp() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamVideo_GetOPFSettings() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamVideo_GetOPFStringForApp() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamVideo_GetVideoURL() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamVideo_IsBroadcasting() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ISteamVideo_SetTimelineGameMode() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_Init() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_InitAnonymousUser() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_InitFlat() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_InitSafe() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_IsSteamRunning() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ManualDispatch_FreeLastCallback() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ManualDispatch_GetAPICallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ManualDispatch_GetNextCallback() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ManualDispatch_Init() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ManualDispatch_RunFrame() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_MatchMakingKeyValuePair_t_Construct() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_RegisterCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_RegisterCallback() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_ReleaseCurrentThreadMemory() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_RestartAppIfNecessary() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_RunCallbacks() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SetBreakpadAppID() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SetMiniDumpComment() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SetTryCatchCallbacks() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_Shutdown() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamAppList_v001() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamApps_v008() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamController_v007() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamController_v008() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamDatagramHostedAddress_Clear() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamDatagramHostedAddress_GetPopID() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamDatagramHostedAddress_SetDevAddress() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamFriends_v017() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamFriends_v018() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamGameSearch_v001() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamGameServerApps_v008() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamGameServerHTTP_v003() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamGameServerInventory_v003() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamGameServerNetworkingMessages_SteamAPI_v002() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamGameServerNetworkingMessages_v002() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamGameServerNetworkingSockets_SteamAPI_v009() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamGameServerNetworkingSockets_SteamAPI_v011() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamGameServerNetworkingSockets_SteamAPI_v012() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamGameServerNetworkingSockets_v008() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamGameServerNetworkingSockets_v009() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamGameServerNetworking_v006() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamGameServerStats_v001() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamGameServerUGC_v014() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamGameServerUGC_v015() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamGameServerUGC_v016() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamGameServerUGC_v017() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamGameServerUGC_v018() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamGameServerUGC_v020() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamGameServerUGC_v021() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamGameServerUtils_v009() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamGameServerUtils_v010() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamGameServer_v013() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamGameServer_v014() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamGameServer_v015() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamHTMLSurface_v005() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamHTTP_v003() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamIPAddress_t_IsSet() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamInput_v001() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamInput_v002() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamInput_v005() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamInput_v006() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamInventory_v003() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamMatchmakingServers_v002() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamMatchmaking_v009() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamMusicRemote_v001() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamMusic_v001() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamNetworkingConfigValue_t_SetFloat() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamNetworkingConfigValue_t_SetInt32() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamNetworkingConfigValue_t_SetInt64() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamNetworkingConfigValue_t_SetPtr() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamNetworkingConfigValue_t_SetString() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamNetworkingIPAddrRender_c_str() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamNetworkingIPAddr_Clear() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamNetworkingIPAddr_GetFakeIPType() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamNetworkingIPAddr_GetIPv4() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamNetworkingIPAddr_IsEqualTo() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamNetworkingIPAddr_IsFakeIP() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamNetworkingIPAddr_IsIPv4() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamNetworkingIPAddr_IsIPv6AllZeros() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamNetworkingIPAddr_IsLocalHost() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamNetworkingIPAddr_ParseString() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamNetworkingIPAddr_SetIPv4() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamNetworkingIPAddr_SetIPv6() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamNetworkingIPAddr_SetIPv6LocalHost() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamNetworkingIPAddr_ToString() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamNetworkingIdentityRender_c_str() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamNetworkingIdentity_Clear() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamNetworkingIdentity_GetFakeIPType() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamNetworkingIdentity_GetGenericBytes() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamNetworkingIdentity_GetGenericString() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamNetworkingIdentity_GetIPAddr() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamNetworkingIdentity_GetIPv4() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamNetworkingIdentity_GetPSNID() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamNetworkingIdentity_GetStadiaID() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamNetworkingIdentity_GetSteamID() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamNetworkingIdentity_GetSteamID64() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamNetworkingIdentity_GetXboxPairwiseID() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamNetworkingIdentity_IsEqualTo() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamNetworkingIdentity_IsFakeIP() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamNetworkingIdentity_IsInvalid() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamNetworkingIdentity_IsLocalHost() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamNetworkingIdentity_ParseString() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamNetworkingIdentity_SetGenericBytes() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamNetworkingIdentity_SetGenericString() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamNetworkingIdentity_SetIPAddr() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamNetworkingIdentity_SetIPv4Addr() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamNetworkingIdentity_SetLocalHost() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamNetworkingIdentity_SetPSNID() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamNetworkingIdentity_SetStadiaID() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamNetworkingIdentity_SetSteamID() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamNetworkingIdentity_SetSteamID64() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamNetworkingIdentity_SetXboxPairwiseID() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamNetworkingIdentity_ToString() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamNetworkingMessage_t_Release() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamNetworkingMessages_SteamAPI_v002() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamNetworkingMessages_v002() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamNetworkingPOPIDRender_c_str() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamNetworkingSockets_SteamAPI_v009() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamNetworkingSockets_SteamAPI_v011() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamNetworkingSockets_SteamAPI_v012() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamNetworkingSockets_v008() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamNetworkingSockets_v009() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamNetworkingUtils_SteamAPI_v003() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamNetworkingUtils_SteamAPI_v004() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamNetworkingUtils_v003() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamNetworking_v006() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamParentalSettings_v001() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamParties_v002() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamRemotePlay_v001() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamRemotePlay_v002() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamRemotePlay_v003() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamRemoteStorage_v014() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamRemoteStorage_v016() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamScreenshots_v003() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamTV_v001() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamTimeline_v001() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamTimeline_v004() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamUGC_v014() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamUGC_v015() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamUGC_v016() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamUGC_v017() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamUGC_v018() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamUGC_v020() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamUGC_v021() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamUserStats_v011() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamUserStats_v012() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamUserStats_v013() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamUser_v020() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamUser_v021() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamUser_v022() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamUser_v023() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamUtils_v009() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamUtils_v010() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamVideo_v002() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamVideo_v003() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamVideo_v004() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_SteamVideo_v007() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_UnregisterCallResult() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_UnregisterCallback() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_UseBreakpadCrashHandler() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_WriteMiniDump() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_gameserveritem_t_Construct() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_gameserveritem_t_GetName() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_gameserveritem_t_SetName() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_servernetadr_t_Assign() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_servernetadr_t_Construct() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_servernetadr_t_GetConnectionAddressString() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_servernetadr_t_GetConnectionPort() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_servernetadr_t_GetIP() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_servernetadr_t_GetQueryAddressString() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_servernetadr_t_GetQueryPort() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_servernetadr_t_Init() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_servernetadr_t_IsLessThan() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_servernetadr_t_SetConnectionPort() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_servernetadr_t_SetIP() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAPI_servernetadr_t_SetQueryPort() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamAppList() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamApps() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamClient() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamContentServer() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamContentServerUtils() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamContentServer_Init() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamContentServer_RunCallbacks() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamContentServer_Shutdown() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamController() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamController_GetControllerState() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamController_Init() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamController_SetOverrideMode() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamController_Shutdown() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamController_TriggerHapticPulse() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamFriends() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamGameServer() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamGameServerApps() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamGameServerHTTP() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamGameServerInventory() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamGameServerNetworking() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamGameServerStats() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamGameServerUGC() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamGameServerUtils() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamGameServer_BSecure() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamGameServer_GetHSteamPipe() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamGameServer_GetHSteamUser() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamGameServer_GetIPCCallCount() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamGameServer_GetSteamID() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamGameServer_Init() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamGameServer_InitSafe() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamGameServer_RunCallbacks() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamGameServer_Shutdown() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamHTMLSurface() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamHTTP() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamInternal_ContextInit() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamInternal_CreateInterface() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamInternal_FindOrCreateGameServerInterface() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamInternal_FindOrCreateUserInterface() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamInternal_GameServer_Init() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamInternal_GameServer_Init_V2() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamInternal_GlobalContextGameServerPtr() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamInternal_SteamAPI_Init() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamInventory() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamMatchmaking() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamMatchmakingServers() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamMusic() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamMusicRemote() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamNetworking() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamRealPath() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamRemoteStorage() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamScreenshots() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamUGC() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamUnifiedMessages() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamUser() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamUserStats() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamUtils() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamVR_ComputeDistortion() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamVR_GetD3D9AdapterIndex() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamVR_GetDisplayId() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamVR_GetDriverId() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamVR_GetEyeOutputViewport() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamVR_GetHeadFromEyePose() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamVR_GetLastTrackerFromHeadPose() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamVR_GetProjectionMatrix() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamVR_GetProjectionRaw() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamVR_GetRecommendedRenderTargetSize() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamVR_GetTrackerFromHeadPose() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamVR_GetTrackerZeroPose() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamVR_GetViewMatrix() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamVR_GetWindowBounds() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamVR_IHmd_Version() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamVR_WillDriftInYaw() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamVR_ZeroTracker() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void SteamVideo() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void Steam_GetHSteamUserCurrent() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void Steam_RegisterInterfaceFuncs() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void Steam_RunCallbacks() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void VR_GetControlPanel() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void VR_GetGenericInterface() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void VR_GetStringForHmdError() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void VR_Init() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void VR_IsHmdPresent() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void VR_Shutdown() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void __gcclibcxx_demangle_callback() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void __gxx_personality_v0() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void __new_handler() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void __wrap___lxstat() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void __wrap___lxstat64() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void __wrap___xstat() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void __wrap___xstat64() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void __wrap_access() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void __wrap_chdir() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void __wrap_chmod() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void __wrap_chown() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void __wrap_dlmopen() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void __wrap_dlopen() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void __wrap_fopen() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void __wrap_fopen64() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void __wrap_freopen() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void __wrap_lchown() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void __wrap_link() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void __wrap_lstat() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void __wrap_lstat64() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void __wrap_mkdir() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void __wrap_mkfifo() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void __wrap_mknod() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void __wrap_mount() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void __wrap_open() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void __wrap_open64() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void __wrap_opendir() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void __wrap_rename() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void __wrap_rmdir() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void __wrap_scandir() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void __wrap_scandir64() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void __wrap_stat() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void __wrap_stat64() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void __wrap_statfs() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void __wrap_statfs64() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void __wrap_statvfs() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void __wrap_statvfs64() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void __wrap_symlink() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void __wrap_unlink() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void __wrap_utime() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void __wrap_utimes() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}

EXPORT void g_pSteamClientGameServer() {
    asm volatile ("movabs $0xFeedBeefDeadC0de, %%rax":::"rax");
    asm volatile ("jmp *%rax");
}


namespace {
    void panic_exit(){
        koalabox::util::panic("Invocation of uninitialized exported function.");
    }
}

namespace proxy_exports {
    void init(void* const self_lib_handle, void* const original_lib_handle) {
        static std::mutex section;
        const std::lock_guard lock(section);

        static bool initialized = false;
        if(initialized) {
            LOG_WARN("proxy_exports is already initialized");
            return;
        }

        LOG_INFO(
            "Initializing proxy_exports. self handle: {}, original handle: {}",
            self_lib_handle, original_lib_handle
        );

        const auto code_section = koalabox::lib::get_section_or_throw(self_lib_handle, koalabox::lib::CODE_SECTION);
        PLH::MemAccessor mem_accessor;
        PLH::MemoryProtector const protector(
            reinterpret_cast<uint64_t>(code_section.start_address),
            code_section.size,
            PLH::ProtFlag::RWX,
            mem_accessor
        );

        void* src_address = nullptr;
        void* dest_address = nullptr;

        dest_address = dlsym(self_lib_handle, "CAddAppDependencyResult_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CAddAppDependencyResult_t_RemoveCallResult");
        LOG_TRACE("{} -> 'CAddAppDependencyResult_t_RemoveCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CAddAppDependencyResult_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CAddAppDependencyResult_t_SetCallResult");
        LOG_TRACE("{} -> 'CAddAppDependencyResult_t_SetCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CAddUGCDependencyResult_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CAddUGCDependencyResult_t_RemoveCallResult");
        LOG_TRACE("{} -> 'CAddUGCDependencyResult_t_RemoveCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CAddUGCDependencyResult_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CAddUGCDependencyResult_t_SetCallResult");
        LOG_TRACE("{} -> 'CAddUGCDependencyResult_t_SetCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CAssociateWithClanResult_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CAssociateWithClanResult_t_RemoveCallResult");
        LOG_TRACE("{} -> 'CAssociateWithClanResult_t_RemoveCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CAssociateWithClanResult_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CAssociateWithClanResult_t_SetCallResult");
        LOG_TRACE("{} -> 'CAssociateWithClanResult_t_SetCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CChangeNumOpenSlotsCallback_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CChangeNumOpenSlotsCallback_t_RemoveCallResult");
        LOG_TRACE("{} -> 'CChangeNumOpenSlotsCallback_t_RemoveCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CChangeNumOpenSlotsCallback_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CChangeNumOpenSlotsCallback_t_SetCallResult");
        LOG_TRACE("{} -> 'CChangeNumOpenSlotsCallback_t_SetCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CCheckFileSignature_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CCheckFileSignature_t_RemoveCallResult");
        LOG_TRACE("{} -> 'CCheckFileSignature_t_RemoveCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CCheckFileSignature_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CCheckFileSignature_t_SetCallResult");
        LOG_TRACE("{} -> 'CCheckFileSignature_t_SetCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CClanOfficerListResponse_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CClanOfficerListResponse_t_RemoveCallResult");
        LOG_TRACE("{} -> 'CClanOfficerListResponse_t_RemoveCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CClanOfficerListResponse_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CClanOfficerListResponse_t_SetCallResult");
        LOG_TRACE("{} -> 'CClanOfficerListResponse_t_SetCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CComputeNewPlayerCompatibilityResult_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CComputeNewPlayerCompatibilityResult_t_RemoveCallResult");
        LOG_TRACE("{} -> 'CComputeNewPlayerCompatibilityResult_t_RemoveCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CComputeNewPlayerCompatibilityResult_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CComputeNewPlayerCompatibilityResult_t_SetCallResult");
        LOG_TRACE("{} -> 'CComputeNewPlayerCompatibilityResult_t_SetCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CCreateBeaconCallback_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CCreateBeaconCallback_t_RemoveCallResult");
        LOG_TRACE("{} -> 'CCreateBeaconCallback_t_RemoveCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CCreateBeaconCallback_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CCreateBeaconCallback_t_SetCallResult");
        LOG_TRACE("{} -> 'CCreateBeaconCallback_t_SetCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CCreateItemResult_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CCreateItemResult_t_RemoveCallResult");
        LOG_TRACE("{} -> 'CCreateItemResult_t_RemoveCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CCreateItemResult_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CCreateItemResult_t_SetCallResult");
        LOG_TRACE("{} -> 'CCreateItemResult_t_SetCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CDeleteItemResult_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CDeleteItemResult_t_RemoveCallResult");
        LOG_TRACE("{} -> 'CDeleteItemResult_t_RemoveCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CDeleteItemResult_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CDeleteItemResult_t_SetCallResult");
        LOG_TRACE("{} -> 'CDeleteItemResult_t_SetCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CDurationControl_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CDurationControl_t_RemoveCallResult");
        LOG_TRACE("{} -> 'CDurationControl_t_RemoveCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CDurationControl_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CDurationControl_t_SetCallResult");
        LOG_TRACE("{} -> 'CDurationControl_t_SetCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CEncryptedAppTicketResponse_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CEncryptedAppTicketResponse_t_RemoveCallResult");
        LOG_TRACE("{} -> 'CEncryptedAppTicketResponse_t_RemoveCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CEncryptedAppTicketResponse_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CEncryptedAppTicketResponse_t_SetCallResult");
        LOG_TRACE("{} -> 'CEncryptedAppTicketResponse_t_SetCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CFileDetailsResult_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CFileDetailsResult_t_RemoveCallResult");
        LOG_TRACE("{} -> 'CFileDetailsResult_t_RemoveCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CFileDetailsResult_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CFileDetailsResult_t_SetCallResult");
        LOG_TRACE("{} -> 'CFileDetailsResult_t_SetCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CFriendsEnumerateFollowingList_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CFriendsEnumerateFollowingList_t_RemoveCallResult");
        LOG_TRACE("{} -> 'CFriendsEnumerateFollowingList_t_RemoveCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CFriendsEnumerateFollowingList_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CFriendsEnumerateFollowingList_t_SetCallResult");
        LOG_TRACE("{} -> 'CFriendsEnumerateFollowingList_t_SetCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CFriendsGetFollowerCount_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CFriendsGetFollowerCount_t_RemoveCallResult");
        LOG_TRACE("{} -> 'CFriendsGetFollowerCount_t_RemoveCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CFriendsGetFollowerCount_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CFriendsGetFollowerCount_t_SetCallResult");
        LOG_TRACE("{} -> 'CFriendsGetFollowerCount_t_SetCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CFriendsIsFollowing_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CFriendsIsFollowing_t_RemoveCallResult");
        LOG_TRACE("{} -> 'CFriendsIsFollowing_t_RemoveCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CFriendsIsFollowing_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CFriendsIsFollowing_t_SetCallResult");
        LOG_TRACE("{} -> 'CFriendsIsFollowing_t_SetCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CGSReputation_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CGSReputation_t_RemoveCallResult");
        LOG_TRACE("{} -> 'CGSReputation_t_RemoveCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CGSReputation_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CGSReputation_t_SetCallResult");
        LOG_TRACE("{} -> 'CGSReputation_t_SetCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CGSStatsReceived_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CGSStatsReceived_t_RemoveCallResult");
        LOG_TRACE("{} -> 'CGSStatsReceived_t_RemoveCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CGSStatsReceived_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CGSStatsReceived_t_SetCallResult");
        LOG_TRACE("{} -> 'CGSStatsReceived_t_SetCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CGSStatsStored_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CGSStatsStored_t_RemoveCallResult");
        LOG_TRACE("{} -> 'CGSStatsStored_t_RemoveCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CGSStatsStored_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CGSStatsStored_t_SetCallResult");
        LOG_TRACE("{} -> 'CGSStatsStored_t_SetCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CGetAppDependenciesResult_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CGetAppDependenciesResult_t_RemoveCallResult");
        LOG_TRACE("{} -> 'CGetAppDependenciesResult_t_RemoveCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CGetAppDependenciesResult_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CGetAppDependenciesResult_t_SetCallResult");
        LOG_TRACE("{} -> 'CGetAppDependenciesResult_t_SetCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CGetOPFSettingsResult_t_RemoveCallback");
        src_address = dlsym(original_lib_handle, "CGetOPFSettingsResult_t_RemoveCallback");
        LOG_TRACE("{} -> 'CGetOPFSettingsResult_t_RemoveCallback' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CGetOPFSettingsResult_t_SetCallback");
        src_address = dlsym(original_lib_handle, "CGetOPFSettingsResult_t_SetCallback");
        LOG_TRACE("{} -> 'CGetOPFSettingsResult_t_SetCallback' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CGetUserItemVoteResult_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CGetUserItemVoteResult_t_RemoveCallResult");
        LOG_TRACE("{} -> 'CGetUserItemVoteResult_t_RemoveCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CGetUserItemVoteResult_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CGetUserItemVoteResult_t_SetCallResult");
        LOG_TRACE("{} -> 'CGetUserItemVoteResult_t_SetCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CGlobalAchievementPercentagesReady_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CGlobalAchievementPercentagesReady_t_RemoveCallResult");
        LOG_TRACE("{} -> 'CGlobalAchievementPercentagesReady_t_RemoveCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CGlobalAchievementPercentagesReady_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CGlobalAchievementPercentagesReady_t_SetCallResult");
        LOG_TRACE("{} -> 'CGlobalAchievementPercentagesReady_t_SetCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CGlobalStatsReceived_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CGlobalStatsReceived_t_RemoveCallResult");
        LOG_TRACE("{} -> 'CGlobalStatsReceived_t_RemoveCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CGlobalStatsReceived_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CGlobalStatsReceived_t_SetCallResult");
        LOG_TRACE("{} -> 'CGlobalStatsReceived_t_SetCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CHTML_BrowserReady_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CHTML_BrowserReady_t_RemoveCallResult");
        LOG_TRACE("{} -> 'CHTML_BrowserReady_t_RemoveCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CHTML_BrowserReady_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CHTML_BrowserReady_t_SetCallResult");
        LOG_TRACE("{} -> 'CHTML_BrowserReady_t_SetCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CJoinClanChatRoomCompletionResult_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CJoinClanChatRoomCompletionResult_t_RemoveCallResult");
        LOG_TRACE("{} -> 'CJoinClanChatRoomCompletionResult_t_RemoveCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CJoinClanChatRoomCompletionResult_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CJoinClanChatRoomCompletionResult_t_SetCallResult");
        LOG_TRACE("{} -> 'CJoinClanChatRoomCompletionResult_t_SetCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CJoinPartyCallback_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CJoinPartyCallback_t_RemoveCallResult");
        LOG_TRACE("{} -> 'CJoinPartyCallback_t_RemoveCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CJoinPartyCallback_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CJoinPartyCallback_t_SetCallResult");
        LOG_TRACE("{} -> 'CJoinPartyCallback_t_SetCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CLeaderboardFindResult_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CLeaderboardFindResult_t_RemoveCallResult");
        LOG_TRACE("{} -> 'CLeaderboardFindResult_t_RemoveCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CLeaderboardFindResult_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CLeaderboardFindResult_t_SetCallResult");
        LOG_TRACE("{} -> 'CLeaderboardFindResult_t_SetCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CLeaderboardScoreUploaded_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CLeaderboardScoreUploaded_t_RemoveCallResult");
        LOG_TRACE("{} -> 'CLeaderboardScoreUploaded_t_RemoveCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CLeaderboardScoreUploaded_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CLeaderboardScoreUploaded_t_SetCallResult");
        LOG_TRACE("{} -> 'CLeaderboardScoreUploaded_t_SetCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CLeaderboardScoresDownloaded_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CLeaderboardScoresDownloaded_t_RemoveCallResult");
        LOG_TRACE("{} -> 'CLeaderboardScoresDownloaded_t_RemoveCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CLeaderboardScoresDownloaded_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CLeaderboardScoresDownloaded_t_SetCallResult");
        LOG_TRACE("{} -> 'CLeaderboardScoresDownloaded_t_SetCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CLeaderboardUGCSet_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CLeaderboardUGCSet_t_RemoveCallResult");
        LOG_TRACE("{} -> 'CLeaderboardUGCSet_t_RemoveCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CLeaderboardUGCSet_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CLeaderboardUGCSet_t_SetCallResult");
        LOG_TRACE("{} -> 'CLeaderboardUGCSet_t_SetCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CLobbyCreated_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CLobbyCreated_t_RemoveCallResult");
        LOG_TRACE("{} -> 'CLobbyCreated_t_RemoveCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CLobbyCreated_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CLobbyCreated_t_SetCallResult");
        LOG_TRACE("{} -> 'CLobbyCreated_t_SetCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CLobbyEnter_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CLobbyEnter_t_RemoveCallResult");
        LOG_TRACE("{} -> 'CLobbyEnter_t_RemoveCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CLobbyEnter_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CLobbyEnter_t_SetCallResult");
        LOG_TRACE("{} -> 'CLobbyEnter_t_SetCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CLobbyMatchList_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CLobbyMatchList_t_RemoveCallResult");
        LOG_TRACE("{} -> 'CLobbyMatchList_t_RemoveCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CLobbyMatchList_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CLobbyMatchList_t_SetCallResult");
        LOG_TRACE("{} -> 'CLobbyMatchList_t_SetCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CMarketEligibilityResponse_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CMarketEligibilityResponse_t_RemoveCallResult");
        LOG_TRACE("{} -> 'CMarketEligibilityResponse_t_RemoveCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CMarketEligibilityResponse_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CMarketEligibilityResponse_t_SetCallResult");
        LOG_TRACE("{} -> 'CMarketEligibilityResponse_t_SetCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CNumberOfCurrentPlayers_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CNumberOfCurrentPlayers_t_RemoveCallResult");
        LOG_TRACE("{} -> 'CNumberOfCurrentPlayers_t_RemoveCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CNumberOfCurrentPlayers_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CNumberOfCurrentPlayers_t_SetCallResult");
        LOG_TRACE("{} -> 'CNumberOfCurrentPlayers_t_SetCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CPublisherOwnedAppDataReady_t_RemoveCallback");
        src_address = dlsym(original_lib_handle, "CPublisherOwnedAppDataReady_t_RemoveCallback");
        LOG_TRACE("{} -> 'CPublisherOwnedAppDataReady_t_RemoveCallback' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CPublisherOwnedAppDataReady_t_SetCallback");
        src_address = dlsym(original_lib_handle, "CPublisherOwnedAppDataReady_t_SetCallback");
        LOG_TRACE("{} -> 'CPublisherOwnedAppDataReady_t_SetCallback' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CRemoteStorageDeletePublishedFileResult_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CRemoteStorageDeletePublishedFileResult_t_RemoveCallResult");
        LOG_TRACE("{} -> 'CRemoteStorageDeletePublishedFileResult_t_RemoveCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CRemoteStorageDeletePublishedFileResult_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CRemoteStorageDeletePublishedFileResult_t_SetCallResult");
        LOG_TRACE("{} -> 'CRemoteStorageDeletePublishedFileResult_t_SetCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CRemoteStorageDownloadUGCResult_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CRemoteStorageDownloadUGCResult_t_RemoveCallResult");
        LOG_TRACE("{} -> 'CRemoteStorageDownloadUGCResult_t_RemoveCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CRemoteStorageDownloadUGCResult_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CRemoteStorageDownloadUGCResult_t_SetCallResult");
        LOG_TRACE("{} -> 'CRemoteStorageDownloadUGCResult_t_SetCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CRemoteStorageEnumeratePublishedFilesByUserActionResult_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CRemoteStorageEnumeratePublishedFilesByUserActionResult_t_RemoveCallResult");
        LOG_TRACE("{} -> 'CRemoteStorageEnumeratePublishedFilesByUserActionResult_t_RemoveCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CRemoteStorageEnumeratePublishedFilesByUserActionResult_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CRemoteStorageEnumeratePublishedFilesByUserActionResult_t_SetCallResult");
        LOG_TRACE("{} -> 'CRemoteStorageEnumeratePublishedFilesByUserActionResult_t_SetCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CRemoteStorageEnumerateUserPublishedFilesResult_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CRemoteStorageEnumerateUserPublishedFilesResult_t_RemoveCallResult");
        LOG_TRACE("{} -> 'CRemoteStorageEnumerateUserPublishedFilesResult_t_RemoveCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CRemoteStorageEnumerateUserPublishedFilesResult_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CRemoteStorageEnumerateUserPublishedFilesResult_t_SetCallResult");
        LOG_TRACE("{} -> 'CRemoteStorageEnumerateUserPublishedFilesResult_t_SetCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CRemoteStorageEnumerateUserSubscribedFilesResult_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CRemoteStorageEnumerateUserSubscribedFilesResult_t_RemoveCallResult");
        LOG_TRACE("{} -> 'CRemoteStorageEnumerateUserSubscribedFilesResult_t_RemoveCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CRemoteStorageEnumerateUserSubscribedFilesResult_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CRemoteStorageEnumerateUserSubscribedFilesResult_t_SetCallResult");
        LOG_TRACE("{} -> 'CRemoteStorageEnumerateUserSubscribedFilesResult_t_SetCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CRemoteStorageEnumerateWorkshopFilesResult_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CRemoteStorageEnumerateWorkshopFilesResult_t_RemoveCallResult");
        LOG_TRACE("{} -> 'CRemoteStorageEnumerateWorkshopFilesResult_t_RemoveCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CRemoteStorageEnumerateWorkshopFilesResult_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CRemoteStorageEnumerateWorkshopFilesResult_t_SetCallResult");
        LOG_TRACE("{} -> 'CRemoteStorageEnumerateWorkshopFilesResult_t_SetCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CRemoteStorageFileReadAsyncComplete_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CRemoteStorageFileReadAsyncComplete_t_RemoveCallResult");
        LOG_TRACE("{} -> 'CRemoteStorageFileReadAsyncComplete_t_RemoveCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CRemoteStorageFileReadAsyncComplete_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CRemoteStorageFileReadAsyncComplete_t_SetCallResult");
        LOG_TRACE("{} -> 'CRemoteStorageFileReadAsyncComplete_t_SetCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CRemoteStorageFileShareResult_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CRemoteStorageFileShareResult_t_RemoveCallResult");
        LOG_TRACE("{} -> 'CRemoteStorageFileShareResult_t_RemoveCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CRemoteStorageFileShareResult_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CRemoteStorageFileShareResult_t_SetCallResult");
        LOG_TRACE("{} -> 'CRemoteStorageFileShareResult_t_SetCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CRemoteStorageFileWriteAsyncComplete_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CRemoteStorageFileWriteAsyncComplete_t_RemoveCallResult");
        LOG_TRACE("{} -> 'CRemoteStorageFileWriteAsyncComplete_t_RemoveCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CRemoteStorageFileWriteAsyncComplete_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CRemoteStorageFileWriteAsyncComplete_t_SetCallResult");
        LOG_TRACE("{} -> 'CRemoteStorageFileWriteAsyncComplete_t_SetCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CRemoteStorageGetPublishedFileDetailsResult_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CRemoteStorageGetPublishedFileDetailsResult_t_RemoveCallResult");
        LOG_TRACE("{} -> 'CRemoteStorageGetPublishedFileDetailsResult_t_RemoveCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CRemoteStorageGetPublishedFileDetailsResult_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CRemoteStorageGetPublishedFileDetailsResult_t_SetCallResult");
        LOG_TRACE("{} -> 'CRemoteStorageGetPublishedFileDetailsResult_t_SetCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CRemoteStorageGetPublishedItemVoteDetailsResult_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CRemoteStorageGetPublishedItemVoteDetailsResult_t_RemoveCallResult");
        LOG_TRACE("{} -> 'CRemoteStorageGetPublishedItemVoteDetailsResult_t_RemoveCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CRemoteStorageGetPublishedItemVoteDetailsResult_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CRemoteStorageGetPublishedItemVoteDetailsResult_t_SetCallResult");
        LOG_TRACE("{} -> 'CRemoteStorageGetPublishedItemVoteDetailsResult_t_SetCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CRemoteStoragePublishFileProgress_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CRemoteStoragePublishFileProgress_t_RemoveCallResult");
        LOG_TRACE("{} -> 'CRemoteStoragePublishFileProgress_t_RemoveCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CRemoteStoragePublishFileProgress_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CRemoteStoragePublishFileProgress_t_SetCallResult");
        LOG_TRACE("{} -> 'CRemoteStoragePublishFileProgress_t_SetCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CRemoteStorageSetUserPublishedFileActionResult_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CRemoteStorageSetUserPublishedFileActionResult_t_RemoveCallResult");
        LOG_TRACE("{} -> 'CRemoteStorageSetUserPublishedFileActionResult_t_RemoveCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CRemoteStorageSetUserPublishedFileActionResult_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CRemoteStorageSetUserPublishedFileActionResult_t_SetCallResult");
        LOG_TRACE("{} -> 'CRemoteStorageSetUserPublishedFileActionResult_t_SetCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CRemoteStorageSubscribePublishedFileResult_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CRemoteStorageSubscribePublishedFileResult_t_RemoveCallResult");
        LOG_TRACE("{} -> 'CRemoteStorageSubscribePublishedFileResult_t_RemoveCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CRemoteStorageSubscribePublishedFileResult_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CRemoteStorageSubscribePublishedFileResult_t_SetCallResult");
        LOG_TRACE("{} -> 'CRemoteStorageSubscribePublishedFileResult_t_SetCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CRemoteStorageUnsubscribePublishedFileResult_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CRemoteStorageUnsubscribePublishedFileResult_t_RemoveCallResult");
        LOG_TRACE("{} -> 'CRemoteStorageUnsubscribePublishedFileResult_t_RemoveCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CRemoteStorageUnsubscribePublishedFileResult_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CRemoteStorageUnsubscribePublishedFileResult_t_SetCallResult");
        LOG_TRACE("{} -> 'CRemoteStorageUnsubscribePublishedFileResult_t_SetCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CRemoteStorageUpdatePublishedFileResult_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CRemoteStorageUpdatePublishedFileResult_t_RemoveCallResult");
        LOG_TRACE("{} -> 'CRemoteStorageUpdatePublishedFileResult_t_RemoveCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CRemoteStorageUpdatePublishedFileResult_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CRemoteStorageUpdatePublishedFileResult_t_SetCallResult");
        LOG_TRACE("{} -> 'CRemoteStorageUpdatePublishedFileResult_t_SetCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CRemoteStorageUpdateUserPublishedItemVoteResult_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CRemoteStorageUpdateUserPublishedItemVoteResult_t_RemoveCallResult");
        LOG_TRACE("{} -> 'CRemoteStorageUpdateUserPublishedItemVoteResult_t_RemoveCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CRemoteStorageUpdateUserPublishedItemVoteResult_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CRemoteStorageUpdateUserPublishedItemVoteResult_t_SetCallResult");
        LOG_TRACE("{} -> 'CRemoteStorageUpdateUserPublishedItemVoteResult_t_SetCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CRemoveAppDependencyResult_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CRemoveAppDependencyResult_t_RemoveCallResult");
        LOG_TRACE("{} -> 'CRemoveAppDependencyResult_t_RemoveCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CRemoveAppDependencyResult_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CRemoveAppDependencyResult_t_SetCallResult");
        LOG_TRACE("{} -> 'CRemoveAppDependencyResult_t_SetCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CRemoveUGCDependencyResult_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CRemoveUGCDependencyResult_t_RemoveCallResult");
        LOG_TRACE("{} -> 'CRemoveUGCDependencyResult_t_RemoveCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CRemoveUGCDependencyResult_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CRemoveUGCDependencyResult_t_SetCallResult");
        LOG_TRACE("{} -> 'CRemoveUGCDependencyResult_t_SetCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CSetPersonaNameResponse_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CSetPersonaNameResponse_t_RemoveCallResult");
        LOG_TRACE("{} -> 'CSetPersonaNameResponse_t_RemoveCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CSetPersonaNameResponse_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CSetPersonaNameResponse_t_SetCallResult");
        LOG_TRACE("{} -> 'CSetPersonaNameResponse_t_SetCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CSetUserItemVoteResult_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CSetUserItemVoteResult_t_RemoveCallResult");
        LOG_TRACE("{} -> 'CSetUserItemVoteResult_t_RemoveCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CSetUserItemVoteResult_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CSetUserItemVoteResult_t_SetCallResult");
        LOG_TRACE("{} -> 'CSetUserItemVoteResult_t_SetCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CStartPlaytimeTrackingResult_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CStartPlaytimeTrackingResult_t_RemoveCallResult");
        LOG_TRACE("{} -> 'CStartPlaytimeTrackingResult_t_RemoveCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CStartPlaytimeTrackingResult_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CStartPlaytimeTrackingResult_t_SetCallResult");
        LOG_TRACE("{} -> 'CStartPlaytimeTrackingResult_t_SetCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CSteamInventoryEligiblePromoItemDefIDs_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CSteamInventoryEligiblePromoItemDefIDs_t_RemoveCallResult");
        LOG_TRACE("{} -> 'CSteamInventoryEligiblePromoItemDefIDs_t_RemoveCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CSteamInventoryEligiblePromoItemDefIDs_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CSteamInventoryEligiblePromoItemDefIDs_t_SetCallResult");
        LOG_TRACE("{} -> 'CSteamInventoryEligiblePromoItemDefIDs_t_SetCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CSteamInventoryRequestPricesResult_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CSteamInventoryRequestPricesResult_t_RemoveCallResult");
        LOG_TRACE("{} -> 'CSteamInventoryRequestPricesResult_t_RemoveCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CSteamInventoryRequestPricesResult_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CSteamInventoryRequestPricesResult_t_SetCallResult");
        LOG_TRACE("{} -> 'CSteamInventoryRequestPricesResult_t_SetCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CSteamInventoryStartPurchaseResult_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CSteamInventoryStartPurchaseResult_t_RemoveCallResult");
        LOG_TRACE("{} -> 'CSteamInventoryStartPurchaseResult_t_RemoveCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CSteamInventoryStartPurchaseResult_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CSteamInventoryStartPurchaseResult_t_SetCallResult");
        LOG_TRACE("{} -> 'CSteamInventoryStartPurchaseResult_t_SetCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CSteamUGCQueryCompleted_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CSteamUGCQueryCompleted_t_RemoveCallResult");
        LOG_TRACE("{} -> 'CSteamUGCQueryCompleted_t_RemoveCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CSteamUGCQueryCompleted_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CSteamUGCQueryCompleted_t_SetCallResult");
        LOG_TRACE("{} -> 'CSteamUGCQueryCompleted_t_SetCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CStopPlaytimeTrackingResult_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CStopPlaytimeTrackingResult_t_RemoveCallResult");
        LOG_TRACE("{} -> 'CStopPlaytimeTrackingResult_t_RemoveCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CStopPlaytimeTrackingResult_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CStopPlaytimeTrackingResult_t_SetCallResult");
        LOG_TRACE("{} -> 'CStopPlaytimeTrackingResult_t_SetCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CStoreAuthURLResponse_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CStoreAuthURLResponse_t_RemoveCallResult");
        LOG_TRACE("{} -> 'CStoreAuthURLResponse_t_RemoveCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CStoreAuthURLResponse_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CStoreAuthURLResponse_t_SetCallResult");
        LOG_TRACE("{} -> 'CStoreAuthURLResponse_t_SetCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CSubmitItemUpdateResult_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CSubmitItemUpdateResult_t_RemoveCallResult");
        LOG_TRACE("{} -> 'CSubmitItemUpdateResult_t_RemoveCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CSubmitItemUpdateResult_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CSubmitItemUpdateResult_t_SetCallResult");
        LOG_TRACE("{} -> 'CSubmitItemUpdateResult_t_SetCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CUserFavoriteItemsListChanged_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CUserFavoriteItemsListChanged_t_RemoveCallResult");
        LOG_TRACE("{} -> 'CUserFavoriteItemsListChanged_t_RemoveCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CUserFavoriteItemsListChanged_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CUserFavoriteItemsListChanged_t_SetCallResult");
        LOG_TRACE("{} -> 'CUserFavoriteItemsListChanged_t_SetCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CUserStatsReceived_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CUserStatsReceived_t_RemoveCallResult");
        LOG_TRACE("{} -> 'CUserStatsReceived_t_RemoveCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CUserStatsReceived_t_RemoveCallback");
        src_address = dlsym(original_lib_handle, "CUserStatsReceived_t_RemoveCallback");
        LOG_TRACE("{} -> 'CUserStatsReceived_t_RemoveCallback' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CUserStatsReceived_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CUserStatsReceived_t_SetCallResult");
        LOG_TRACE("{} -> 'CUserStatsReceived_t_SetCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CUserStatsReceived_t_SetCallback");
        src_address = dlsym(original_lib_handle, "CUserStatsReceived_t_SetCallback");
        LOG_TRACE("{} -> 'CUserStatsReceived_t_SetCallback' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "GetHSteamPipe");
        src_address = dlsym(original_lib_handle, "GetHSteamPipe");
        LOG_TRACE("{} -> 'GetHSteamPipe' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "GetHSteamUser");
        src_address = dlsym(original_lib_handle, "GetHSteamUser");
        LOG_TRACE("{} -> 'GetHSteamUser' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_GetHSteamPipe");
        src_address = dlsym(original_lib_handle, "SteamAPI_GetHSteamPipe");
        LOG_TRACE("{} -> 'SteamAPI_GetHSteamPipe' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_GetHSteamUser");
        src_address = dlsym(original_lib_handle, "SteamAPI_GetHSteamUser");
        LOG_TRACE("{} -> 'SteamAPI_GetHSteamUser' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_GetSteamInstallPath");
        src_address = dlsym(original_lib_handle, "SteamAPI_GetSteamInstallPath");
        LOG_TRACE("{} -> 'SteamAPI_GetSteamInstallPath' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamAppList_GetAppBuildId");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamAppList_GetAppBuildId");
        LOG_TRACE("{} -> 'SteamAPI_ISteamAppList_GetAppBuildId' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamAppList_GetAppInstallDir");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamAppList_GetAppInstallDir");
        LOG_TRACE("{} -> 'SteamAPI_ISteamAppList_GetAppInstallDir' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamAppList_GetAppName");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamAppList_GetAppName");
        LOG_TRACE("{} -> 'SteamAPI_ISteamAppList_GetAppName' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamAppList_GetInstalledApps");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamAppList_GetInstalledApps");
        LOG_TRACE("{} -> 'SteamAPI_ISteamAppList_GetInstalledApps' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamAppList_GetNumInstalledApps");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamAppList_GetNumInstalledApps");
        LOG_TRACE("{} -> 'SteamAPI_ISteamAppList_GetNumInstalledApps' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamApps_BGetDLCDataByIndex");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamApps_BGetDLCDataByIndex");
        LOG_TRACE("{} -> 'SteamAPI_ISteamApps_BGetDLCDataByIndex' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamApps_BIsAppInstalled");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamApps_BIsAppInstalled");
        LOG_TRACE("{} -> 'SteamAPI_ISteamApps_BIsAppInstalled' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamApps_BIsCybercafe");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamApps_BIsCybercafe");
        LOG_TRACE("{} -> 'SteamAPI_ISteamApps_BIsCybercafe' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamApps_BIsDlcInstalled");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamApps_BIsDlcInstalled");
        LOG_TRACE("{} -> 'SteamAPI_ISteamApps_BIsDlcInstalled' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamApps_BIsLowViolence");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamApps_BIsLowViolence");
        LOG_TRACE("{} -> 'SteamAPI_ISteamApps_BIsLowViolence' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamApps_BIsSubscribed");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamApps_BIsSubscribed");
        LOG_TRACE("{} -> 'SteamAPI_ISteamApps_BIsSubscribed' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamApps_BIsSubscribedApp");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamApps_BIsSubscribedApp");
        LOG_TRACE("{} -> 'SteamAPI_ISteamApps_BIsSubscribedApp' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamApps_BIsSubscribedFromFamilySharing");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamApps_BIsSubscribedFromFamilySharing");
        LOG_TRACE("{} -> 'SteamAPI_ISteamApps_BIsSubscribedFromFamilySharing' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamApps_BIsSubscribedFromFreeWeekend");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamApps_BIsSubscribedFromFreeWeekend");
        LOG_TRACE("{} -> 'SteamAPI_ISteamApps_BIsSubscribedFromFreeWeekend' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamApps_BIsTimedTrial");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamApps_BIsTimedTrial");
        LOG_TRACE("{} -> 'SteamAPI_ISteamApps_BIsTimedTrial' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamApps_BIsVACBanned");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamApps_BIsVACBanned");
        LOG_TRACE("{} -> 'SteamAPI_ISteamApps_BIsVACBanned' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamApps_GetAppBuildId");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamApps_GetAppBuildId");
        LOG_TRACE("{} -> 'SteamAPI_ISteamApps_GetAppBuildId' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamApps_GetAppInstallDir");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamApps_GetAppInstallDir");
        LOG_TRACE("{} -> 'SteamAPI_ISteamApps_GetAppInstallDir' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamApps_GetAppOwner");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamApps_GetAppOwner");
        LOG_TRACE("{} -> 'SteamAPI_ISteamApps_GetAppOwner' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamApps_GetAvailableGameLanguages");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamApps_GetAvailableGameLanguages");
        LOG_TRACE("{} -> 'SteamAPI_ISteamApps_GetAvailableGameLanguages' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamApps_GetBetaInfo");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamApps_GetBetaInfo");
        LOG_TRACE("{} -> 'SteamAPI_ISteamApps_GetBetaInfo' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamApps_GetCurrentBetaName");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamApps_GetCurrentBetaName");
        LOG_TRACE("{} -> 'SteamAPI_ISteamApps_GetCurrentBetaName' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamApps_GetCurrentGameLanguage");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamApps_GetCurrentGameLanguage");
        LOG_TRACE("{} -> 'SteamAPI_ISteamApps_GetCurrentGameLanguage' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamApps_GetDLCCount");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamApps_GetDLCCount");
        LOG_TRACE("{} -> 'SteamAPI_ISteamApps_GetDLCCount' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamApps_GetDlcDownloadProgress");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamApps_GetDlcDownloadProgress");
        LOG_TRACE("{} -> 'SteamAPI_ISteamApps_GetDlcDownloadProgress' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamApps_GetEarliestPurchaseUnixTime");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamApps_GetEarliestPurchaseUnixTime");
        LOG_TRACE("{} -> 'SteamAPI_ISteamApps_GetEarliestPurchaseUnixTime' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamApps_GetFileDetails");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamApps_GetFileDetails");
        LOG_TRACE("{} -> 'SteamAPI_ISteamApps_GetFileDetails' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamApps_GetInstalledDepots");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamApps_GetInstalledDepots");
        LOG_TRACE("{} -> 'SteamAPI_ISteamApps_GetInstalledDepots' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamApps_GetLaunchCommandLine");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamApps_GetLaunchCommandLine");
        LOG_TRACE("{} -> 'SteamAPI_ISteamApps_GetLaunchCommandLine' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamApps_GetLaunchQueryParam");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamApps_GetLaunchQueryParam");
        LOG_TRACE("{} -> 'SteamAPI_ISteamApps_GetLaunchQueryParam' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamApps_GetNumBetas");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamApps_GetNumBetas");
        LOG_TRACE("{} -> 'SteamAPI_ISteamApps_GetNumBetas' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamApps_GetPublisherOwnedAppData");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamApps_GetPublisherOwnedAppData");
        LOG_TRACE("{} -> 'SteamAPI_ISteamApps_GetPublisherOwnedAppData' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamApps_InstallDLC");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamApps_InstallDLC");
        LOG_TRACE("{} -> 'SteamAPI_ISteamApps_InstallDLC' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamApps_MarkContentCorrupt");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamApps_MarkContentCorrupt");
        LOG_TRACE("{} -> 'SteamAPI_ISteamApps_MarkContentCorrupt' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamApps_RequestAllProofOfPurchaseKeys");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamApps_RequestAllProofOfPurchaseKeys");
        LOG_TRACE("{} -> 'SteamAPI_ISteamApps_RequestAllProofOfPurchaseKeys' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamApps_RequestAppProofOfPurchaseKey");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamApps_RequestAppProofOfPurchaseKey");
        LOG_TRACE("{} -> 'SteamAPI_ISteamApps_RequestAppProofOfPurchaseKey' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamApps_RequestPublisherOwnedAppData");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamApps_RequestPublisherOwnedAppData");
        LOG_TRACE("{} -> 'SteamAPI_ISteamApps_RequestPublisherOwnedAppData' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamApps_SetActiveBeta");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamApps_SetActiveBeta");
        LOG_TRACE("{} -> 'SteamAPI_ISteamApps_SetActiveBeta' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamApps_SetDlcContext");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamApps_SetDlcContext");
        LOG_TRACE("{} -> 'SteamAPI_ISteamApps_SetDlcContext' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamApps_UninstallDLC");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamApps_UninstallDLC");
        LOG_TRACE("{} -> 'SteamAPI_ISteamApps_UninstallDLC' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamClient_BReleaseSteamPipe");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamClient_BReleaseSteamPipe");
        LOG_TRACE("{} -> 'SteamAPI_ISteamClient_BReleaseSteamPipe' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamClient_BShutdownIfAllPipesClosed");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamClient_BShutdownIfAllPipesClosed");
        LOG_TRACE("{} -> 'SteamAPI_ISteamClient_BShutdownIfAllPipesClosed' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamClient_ConnectToGlobalUser");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamClient_ConnectToGlobalUser");
        LOG_TRACE("{} -> 'SteamAPI_ISteamClient_ConnectToGlobalUser' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamClient_CreateLocalUser");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamClient_CreateLocalUser");
        LOG_TRACE("{} -> 'SteamAPI_ISteamClient_CreateLocalUser' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamClient_CreateSteamPipe");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamClient_CreateSteamPipe");
        LOG_TRACE("{} -> 'SteamAPI_ISteamClient_CreateSteamPipe' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamClient_GetIPCCallCount");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamClient_GetIPCCallCount");
        LOG_TRACE("{} -> 'SteamAPI_ISteamClient_GetIPCCallCount' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamClient_GetISteamAppList");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamClient_GetISteamAppList");
        LOG_TRACE("{} -> 'SteamAPI_ISteamClient_GetISteamAppList' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamClient_GetISteamApps");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamClient_GetISteamApps");
        LOG_TRACE("{} -> 'SteamAPI_ISteamClient_GetISteamApps' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamClient_GetISteamController");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamClient_GetISteamController");
        LOG_TRACE("{} -> 'SteamAPI_ISteamClient_GetISteamController' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamClient_GetISteamFriends");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamClient_GetISteamFriends");
        LOG_TRACE("{} -> 'SteamAPI_ISteamClient_GetISteamFriends' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamClient_GetISteamGameSearch");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamClient_GetISteamGameSearch");
        LOG_TRACE("{} -> 'SteamAPI_ISteamClient_GetISteamGameSearch' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamClient_GetISteamGameServer");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamClient_GetISteamGameServer");
        LOG_TRACE("{} -> 'SteamAPI_ISteamClient_GetISteamGameServer' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamClient_GetISteamGameServerStats");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamClient_GetISteamGameServerStats");
        LOG_TRACE("{} -> 'SteamAPI_ISteamClient_GetISteamGameServerStats' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamClient_GetISteamGenericInterface");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamClient_GetISteamGenericInterface");
        LOG_TRACE("{} -> 'SteamAPI_ISteamClient_GetISteamGenericInterface' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamClient_GetISteamHTMLSurface");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamClient_GetISteamHTMLSurface");
        LOG_TRACE("{} -> 'SteamAPI_ISteamClient_GetISteamHTMLSurface' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamClient_GetISteamHTTP");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamClient_GetISteamHTTP");
        LOG_TRACE("{} -> 'SteamAPI_ISteamClient_GetISteamHTTP' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamClient_GetISteamInput");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamClient_GetISteamInput");
        LOG_TRACE("{} -> 'SteamAPI_ISteamClient_GetISteamInput' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamClient_GetISteamInventory");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamClient_GetISteamInventory");
        LOG_TRACE("{} -> 'SteamAPI_ISteamClient_GetISteamInventory' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamClient_GetISteamMatchmaking");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamClient_GetISteamMatchmaking");
        LOG_TRACE("{} -> 'SteamAPI_ISteamClient_GetISteamMatchmaking' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamClient_GetISteamMatchmakingServers");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamClient_GetISteamMatchmakingServers");
        LOG_TRACE("{} -> 'SteamAPI_ISteamClient_GetISteamMatchmakingServers' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamClient_GetISteamMusic");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamClient_GetISteamMusic");
        LOG_TRACE("{} -> 'SteamAPI_ISteamClient_GetISteamMusic' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamClient_GetISteamMusicRemote");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamClient_GetISteamMusicRemote");
        LOG_TRACE("{} -> 'SteamAPI_ISteamClient_GetISteamMusicRemote' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamClient_GetISteamNetworking");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamClient_GetISteamNetworking");
        LOG_TRACE("{} -> 'SteamAPI_ISteamClient_GetISteamNetworking' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamClient_GetISteamParentalSettings");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamClient_GetISteamParentalSettings");
        LOG_TRACE("{} -> 'SteamAPI_ISteamClient_GetISteamParentalSettings' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamClient_GetISteamParties");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamClient_GetISteamParties");
        LOG_TRACE("{} -> 'SteamAPI_ISteamClient_GetISteamParties' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamClient_GetISteamRemotePlay");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamClient_GetISteamRemotePlay");
        LOG_TRACE("{} -> 'SteamAPI_ISteamClient_GetISteamRemotePlay' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamClient_GetISteamRemoteStorage");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamClient_GetISteamRemoteStorage");
        LOG_TRACE("{} -> 'SteamAPI_ISteamClient_GetISteamRemoteStorage' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamClient_GetISteamScreenshots");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamClient_GetISteamScreenshots");
        LOG_TRACE("{} -> 'SteamAPI_ISteamClient_GetISteamScreenshots' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamClient_GetISteamUGC");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamClient_GetISteamUGC");
        LOG_TRACE("{} -> 'SteamAPI_ISteamClient_GetISteamUGC' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamClient_GetISteamUnifiedMessages");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamClient_GetISteamUnifiedMessages");
        LOG_TRACE("{} -> 'SteamAPI_ISteamClient_GetISteamUnifiedMessages' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamClient_GetISteamUser");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamClient_GetISteamUser");
        LOG_TRACE("{} -> 'SteamAPI_ISteamClient_GetISteamUser' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamClient_GetISteamUserStats");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamClient_GetISteamUserStats");
        LOG_TRACE("{} -> 'SteamAPI_ISteamClient_GetISteamUserStats' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamClient_GetISteamUtils");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamClient_GetISteamUtils");
        LOG_TRACE("{} -> 'SteamAPI_ISteamClient_GetISteamUtils' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamClient_GetISteamVideo");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamClient_GetISteamVideo");
        LOG_TRACE("{} -> 'SteamAPI_ISteamClient_GetISteamVideo' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamClient_ReleaseUser");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamClient_ReleaseUser");
        LOG_TRACE("{} -> 'SteamAPI_ISteamClient_ReleaseUser' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamClient_Remove_SteamAPI_CPostAPIResultInProcess");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamClient_Remove_SteamAPI_CPostAPIResultInProcess");
        LOG_TRACE("{} -> 'SteamAPI_ISteamClient_Remove_SteamAPI_CPostAPIResultInProcess' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamClient_RunFrame");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamClient_RunFrame");
        LOG_TRACE("{} -> 'SteamAPI_ISteamClient_RunFrame' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamClient_SetLocalIPBinding");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamClient_SetLocalIPBinding");
        LOG_TRACE("{} -> 'SteamAPI_ISteamClient_SetLocalIPBinding' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamClient_SetWarningMessageHook");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamClient_SetWarningMessageHook");
        LOG_TRACE("{} -> 'SteamAPI_ISteamClient_SetWarningMessageHook' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamClient_Set_SteamAPI_CCheckCallbackRegisteredInProcess");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamClient_Set_SteamAPI_CCheckCallbackRegisteredInProcess");
        LOG_TRACE("{} -> 'SteamAPI_ISteamClient_Set_SteamAPI_CCheckCallbackRegisteredInProcess' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamClient_Set_SteamAPI_CPostAPIResultInProcess");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamClient_Set_SteamAPI_CPostAPIResultInProcess");
        LOG_TRACE("{} -> 'SteamAPI_ISteamClient_Set_SteamAPI_CPostAPIResultInProcess' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamController_ActivateActionSet");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamController_ActivateActionSet");
        LOG_TRACE("{} -> 'SteamAPI_ISteamController_ActivateActionSet' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamController_ActivateActionSetLayer");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamController_ActivateActionSetLayer");
        LOG_TRACE("{} -> 'SteamAPI_ISteamController_ActivateActionSetLayer' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamController_DeactivateActionSetLayer");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamController_DeactivateActionSetLayer");
        LOG_TRACE("{} -> 'SteamAPI_ISteamController_DeactivateActionSetLayer' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamController_DeactivateAllActionSetLayers");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamController_DeactivateAllActionSetLayers");
        LOG_TRACE("{} -> 'SteamAPI_ISteamController_DeactivateAllActionSetLayers' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamController_GetActionOriginFromXboxOrigin");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamController_GetActionOriginFromXboxOrigin");
        LOG_TRACE("{} -> 'SteamAPI_ISteamController_GetActionOriginFromXboxOrigin' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamController_GetActionSetHandle");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamController_GetActionSetHandle");
        LOG_TRACE("{} -> 'SteamAPI_ISteamController_GetActionSetHandle' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamController_GetActiveActionSetLayers");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamController_GetActiveActionSetLayers");
        LOG_TRACE("{} -> 'SteamAPI_ISteamController_GetActiveActionSetLayers' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamController_GetAnalogActionData");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamController_GetAnalogActionData");
        LOG_TRACE("{} -> 'SteamAPI_ISteamController_GetAnalogActionData' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamController_GetAnalogActionHandle");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamController_GetAnalogActionHandle");
        LOG_TRACE("{} -> 'SteamAPI_ISteamController_GetAnalogActionHandle' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamController_GetAnalogActionOrigins");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamController_GetAnalogActionOrigins");
        LOG_TRACE("{} -> 'SteamAPI_ISteamController_GetAnalogActionOrigins' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamController_GetConnectedControllers");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamController_GetConnectedControllers");
        LOG_TRACE("{} -> 'SteamAPI_ISteamController_GetConnectedControllers' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamController_GetControllerBindingRevision");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamController_GetControllerBindingRevision");
        LOG_TRACE("{} -> 'SteamAPI_ISteamController_GetControllerBindingRevision' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamController_GetControllerForGamepadIndex");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamController_GetControllerForGamepadIndex");
        LOG_TRACE("{} -> 'SteamAPI_ISteamController_GetControllerForGamepadIndex' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamController_GetControllerState");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamController_GetControllerState");
        LOG_TRACE("{} -> 'SteamAPI_ISteamController_GetControllerState' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamController_GetCurrentActionSet");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamController_GetCurrentActionSet");
        LOG_TRACE("{} -> 'SteamAPI_ISteamController_GetCurrentActionSet' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamController_GetDigitalActionData");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamController_GetDigitalActionData");
        LOG_TRACE("{} -> 'SteamAPI_ISteamController_GetDigitalActionData' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamController_GetDigitalActionHandle");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamController_GetDigitalActionHandle");
        LOG_TRACE("{} -> 'SteamAPI_ISteamController_GetDigitalActionHandle' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamController_GetDigitalActionOrigins");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamController_GetDigitalActionOrigins");
        LOG_TRACE("{} -> 'SteamAPI_ISteamController_GetDigitalActionOrigins' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamController_GetGamepadIndexForController");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamController_GetGamepadIndexForController");
        LOG_TRACE("{} -> 'SteamAPI_ISteamController_GetGamepadIndexForController' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamController_GetGlyphForActionOrigin");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamController_GetGlyphForActionOrigin");
        LOG_TRACE("{} -> 'SteamAPI_ISteamController_GetGlyphForActionOrigin' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamController_GetGlyphForXboxOrigin");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamController_GetGlyphForXboxOrigin");
        LOG_TRACE("{} -> 'SteamAPI_ISteamController_GetGlyphForXboxOrigin' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamController_GetInputTypeForHandle");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamController_GetInputTypeForHandle");
        LOG_TRACE("{} -> 'SteamAPI_ISteamController_GetInputTypeForHandle' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamController_GetMotionData");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamController_GetMotionData");
        LOG_TRACE("{} -> 'SteamAPI_ISteamController_GetMotionData' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamController_GetStringForActionOrigin");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamController_GetStringForActionOrigin");
        LOG_TRACE("{} -> 'SteamAPI_ISteamController_GetStringForActionOrigin' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamController_GetStringForXboxOrigin");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamController_GetStringForXboxOrigin");
        LOG_TRACE("{} -> 'SteamAPI_ISteamController_GetStringForXboxOrigin' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamController_Init");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamController_Init");
        LOG_TRACE("{} -> 'SteamAPI_ISteamController_Init' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamController_RunFrame");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamController_RunFrame");
        LOG_TRACE("{} -> 'SteamAPI_ISteamController_RunFrame' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamController_SetLEDColor");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamController_SetLEDColor");
        LOG_TRACE("{} -> 'SteamAPI_ISteamController_SetLEDColor' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamController_SetOverrideMode");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamController_SetOverrideMode");
        LOG_TRACE("{} -> 'SteamAPI_ISteamController_SetOverrideMode' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamController_ShowAnalogActionOrigins");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamController_ShowAnalogActionOrigins");
        LOG_TRACE("{} -> 'SteamAPI_ISteamController_ShowAnalogActionOrigins' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamController_ShowBindingPanel");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamController_ShowBindingPanel");
        LOG_TRACE("{} -> 'SteamAPI_ISteamController_ShowBindingPanel' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamController_ShowDigitalActionOrigins");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamController_ShowDigitalActionOrigins");
        LOG_TRACE("{} -> 'SteamAPI_ISteamController_ShowDigitalActionOrigins' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamController_Shutdown");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamController_Shutdown");
        LOG_TRACE("{} -> 'SteamAPI_ISteamController_Shutdown' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamController_StopAnalogActionMomentum");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamController_StopAnalogActionMomentum");
        LOG_TRACE("{} -> 'SteamAPI_ISteamController_StopAnalogActionMomentum' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamController_TranslateActionOrigin");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamController_TranslateActionOrigin");
        LOG_TRACE("{} -> 'SteamAPI_ISteamController_TranslateActionOrigin' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamController_TriggerHapticPulse");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamController_TriggerHapticPulse");
        LOG_TRACE("{} -> 'SteamAPI_ISteamController_TriggerHapticPulse' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamController_TriggerRepeatedHapticPulse");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamController_TriggerRepeatedHapticPulse");
        LOG_TRACE("{} -> 'SteamAPI_ISteamController_TriggerRepeatedHapticPulse' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamController_TriggerVibration");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamController_TriggerVibration");
        LOG_TRACE("{} -> 'SteamAPI_ISteamController_TriggerVibration' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_ActivateGameOverlay");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_ActivateGameOverlay");
        LOG_TRACE("{} -> 'SteamAPI_ISteamFriends_ActivateGameOverlay' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_ActivateGameOverlayInviteDialog");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_ActivateGameOverlayInviteDialog");
        LOG_TRACE("{} -> 'SteamAPI_ISteamFriends_ActivateGameOverlayInviteDialog' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_ActivateGameOverlayInviteDialogConnectString");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_ActivateGameOverlayInviteDialogConnectString");
        LOG_TRACE("{} -> 'SteamAPI_ISteamFriends_ActivateGameOverlayInviteDialogConnectString' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_ActivateGameOverlayRemotePlayTogetherInviteDialog");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_ActivateGameOverlayRemotePlayTogetherInviteDialog");
        LOG_TRACE("{} -> 'SteamAPI_ISteamFriends_ActivateGameOverlayRemotePlayTogetherInviteDialog' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_ActivateGameOverlayToStore");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_ActivateGameOverlayToStore");
        LOG_TRACE("{} -> 'SteamAPI_ISteamFriends_ActivateGameOverlayToStore' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_ActivateGameOverlayToUser");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_ActivateGameOverlayToUser");
        LOG_TRACE("{} -> 'SteamAPI_ISteamFriends_ActivateGameOverlayToUser' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_ActivateGameOverlayToWebPage");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_ActivateGameOverlayToWebPage");
        LOG_TRACE("{} -> 'SteamAPI_ISteamFriends_ActivateGameOverlayToWebPage' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_BHasEquippedProfileItem");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_BHasEquippedProfileItem");
        LOG_TRACE("{} -> 'SteamAPI_ISteamFriends_BHasEquippedProfileItem' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_ClearRichPresence");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_ClearRichPresence");
        LOG_TRACE("{} -> 'SteamAPI_ISteamFriends_ClearRichPresence' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_CloseClanChatWindowInSteam");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_CloseClanChatWindowInSteam");
        LOG_TRACE("{} -> 'SteamAPI_ISteamFriends_CloseClanChatWindowInSteam' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_DownloadClanActivityCounts");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_DownloadClanActivityCounts");
        LOG_TRACE("{} -> 'SteamAPI_ISteamFriends_DownloadClanActivityCounts' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_EnumerateFollowingList");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_EnumerateFollowingList");
        LOG_TRACE("{} -> 'SteamAPI_ISteamFriends_EnumerateFollowingList' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_GetChatMemberByIndex");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_GetChatMemberByIndex");
        LOG_TRACE("{} -> 'SteamAPI_ISteamFriends_GetChatMemberByIndex' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_GetClanActivityCounts");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_GetClanActivityCounts");
        LOG_TRACE("{} -> 'SteamAPI_ISteamFriends_GetClanActivityCounts' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_GetClanByIndex");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_GetClanByIndex");
        LOG_TRACE("{} -> 'SteamAPI_ISteamFriends_GetClanByIndex' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_GetClanChatMemberCount");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_GetClanChatMemberCount");
        LOG_TRACE("{} -> 'SteamAPI_ISteamFriends_GetClanChatMemberCount' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_GetClanChatMessage");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_GetClanChatMessage");
        LOG_TRACE("{} -> 'SteamAPI_ISteamFriends_GetClanChatMessage' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_GetClanCount");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_GetClanCount");
        LOG_TRACE("{} -> 'SteamAPI_ISteamFriends_GetClanCount' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_GetClanName");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_GetClanName");
        LOG_TRACE("{} -> 'SteamAPI_ISteamFriends_GetClanName' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_GetClanOfficerByIndex");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_GetClanOfficerByIndex");
        LOG_TRACE("{} -> 'SteamAPI_ISteamFriends_GetClanOfficerByIndex' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_GetClanOfficerCount");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_GetClanOfficerCount");
        LOG_TRACE("{} -> 'SteamAPI_ISteamFriends_GetClanOfficerCount' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_GetClanOwner");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_GetClanOwner");
        LOG_TRACE("{} -> 'SteamAPI_ISteamFriends_GetClanOwner' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_GetClanTag");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_GetClanTag");
        LOG_TRACE("{} -> 'SteamAPI_ISteamFriends_GetClanTag' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_GetCoplayFriend");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_GetCoplayFriend");
        LOG_TRACE("{} -> 'SteamAPI_ISteamFriends_GetCoplayFriend' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_GetCoplayFriendCount");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_GetCoplayFriendCount");
        LOG_TRACE("{} -> 'SteamAPI_ISteamFriends_GetCoplayFriendCount' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_GetFollowerCount");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_GetFollowerCount");
        LOG_TRACE("{} -> 'SteamAPI_ISteamFriends_GetFollowerCount' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_GetFriendByIndex");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_GetFriendByIndex");
        LOG_TRACE("{} -> 'SteamAPI_ISteamFriends_GetFriendByIndex' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_GetFriendCoplayGame");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_GetFriendCoplayGame");
        LOG_TRACE("{} -> 'SteamAPI_ISteamFriends_GetFriendCoplayGame' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_GetFriendCoplayTime");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_GetFriendCoplayTime");
        LOG_TRACE("{} -> 'SteamAPI_ISteamFriends_GetFriendCoplayTime' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_GetFriendCount");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_GetFriendCount");
        LOG_TRACE("{} -> 'SteamAPI_ISteamFriends_GetFriendCount' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_GetFriendCountFromSource");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_GetFriendCountFromSource");
        LOG_TRACE("{} -> 'SteamAPI_ISteamFriends_GetFriendCountFromSource' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_GetFriendFromSourceByIndex");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_GetFriendFromSourceByIndex");
        LOG_TRACE("{} -> 'SteamAPI_ISteamFriends_GetFriendFromSourceByIndex' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_GetFriendGamePlayed");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_GetFriendGamePlayed");
        LOG_TRACE("{} -> 'SteamAPI_ISteamFriends_GetFriendGamePlayed' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_GetFriendMessage");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_GetFriendMessage");
        LOG_TRACE("{} -> 'SteamAPI_ISteamFriends_GetFriendMessage' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_GetFriendPersonaName");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_GetFriendPersonaName");
        LOG_TRACE("{} -> 'SteamAPI_ISteamFriends_GetFriendPersonaName' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_GetFriendPersonaNameHistory");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_GetFriendPersonaNameHistory");
        LOG_TRACE("{} -> 'SteamAPI_ISteamFriends_GetFriendPersonaNameHistory' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_GetFriendPersonaState");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_GetFriendPersonaState");
        LOG_TRACE("{} -> 'SteamAPI_ISteamFriends_GetFriendPersonaState' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_GetFriendRelationship");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_GetFriendRelationship");
        LOG_TRACE("{} -> 'SteamAPI_ISteamFriends_GetFriendRelationship' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_GetFriendRichPresence");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_GetFriendRichPresence");
        LOG_TRACE("{} -> 'SteamAPI_ISteamFriends_GetFriendRichPresence' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_GetFriendRichPresenceKeyByIndex");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_GetFriendRichPresenceKeyByIndex");
        LOG_TRACE("{} -> 'SteamAPI_ISteamFriends_GetFriendRichPresenceKeyByIndex' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_GetFriendRichPresenceKeyCount");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_GetFriendRichPresenceKeyCount");
        LOG_TRACE("{} -> 'SteamAPI_ISteamFriends_GetFriendRichPresenceKeyCount' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_GetFriendSteamLevel");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_GetFriendSteamLevel");
        LOG_TRACE("{} -> 'SteamAPI_ISteamFriends_GetFriendSteamLevel' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_GetFriendsGroupCount");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_GetFriendsGroupCount");
        LOG_TRACE("{} -> 'SteamAPI_ISteamFriends_GetFriendsGroupCount' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_GetFriendsGroupIDByIndex");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_GetFriendsGroupIDByIndex");
        LOG_TRACE("{} -> 'SteamAPI_ISteamFriends_GetFriendsGroupIDByIndex' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_GetFriendsGroupMembersCount");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_GetFriendsGroupMembersCount");
        LOG_TRACE("{} -> 'SteamAPI_ISteamFriends_GetFriendsGroupMembersCount' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_GetFriendsGroupMembersList");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_GetFriendsGroupMembersList");
        LOG_TRACE("{} -> 'SteamAPI_ISteamFriends_GetFriendsGroupMembersList' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_GetFriendsGroupName");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_GetFriendsGroupName");
        LOG_TRACE("{} -> 'SteamAPI_ISteamFriends_GetFriendsGroupName' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_GetLargeFriendAvatar");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_GetLargeFriendAvatar");
        LOG_TRACE("{} -> 'SteamAPI_ISteamFriends_GetLargeFriendAvatar' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_GetMediumFriendAvatar");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_GetMediumFriendAvatar");
        LOG_TRACE("{} -> 'SteamAPI_ISteamFriends_GetMediumFriendAvatar' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_GetNumChatsWithUnreadPriorityMessages");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_GetNumChatsWithUnreadPriorityMessages");
        LOG_TRACE("{} -> 'SteamAPI_ISteamFriends_GetNumChatsWithUnreadPriorityMessages' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_GetPersonaName");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_GetPersonaName");
        LOG_TRACE("{} -> 'SteamAPI_ISteamFriends_GetPersonaName' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_GetPersonaState");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_GetPersonaState");
        LOG_TRACE("{} -> 'SteamAPI_ISteamFriends_GetPersonaState' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_GetPlayerNickname");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_GetPlayerNickname");
        LOG_TRACE("{} -> 'SteamAPI_ISteamFriends_GetPlayerNickname' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_GetProfileItemPropertyString");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_GetProfileItemPropertyString");
        LOG_TRACE("{} -> 'SteamAPI_ISteamFriends_GetProfileItemPropertyString' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_GetProfileItemPropertyUint");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_GetProfileItemPropertyUint");
        LOG_TRACE("{} -> 'SteamAPI_ISteamFriends_GetProfileItemPropertyUint' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_GetSmallFriendAvatar");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_GetSmallFriendAvatar");
        LOG_TRACE("{} -> 'SteamAPI_ISteamFriends_GetSmallFriendAvatar' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_GetUserRestrictions");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_GetUserRestrictions");
        LOG_TRACE("{} -> 'SteamAPI_ISteamFriends_GetUserRestrictions' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_HasFriend");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_HasFriend");
        LOG_TRACE("{} -> 'SteamAPI_ISteamFriends_HasFriend' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_InviteUserToGame");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_InviteUserToGame");
        LOG_TRACE("{} -> 'SteamAPI_ISteamFriends_InviteUserToGame' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_IsClanChatAdmin");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_IsClanChatAdmin");
        LOG_TRACE("{} -> 'SteamAPI_ISteamFriends_IsClanChatAdmin' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_IsClanChatWindowOpenInSteam");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_IsClanChatWindowOpenInSteam");
        LOG_TRACE("{} -> 'SteamAPI_ISteamFriends_IsClanChatWindowOpenInSteam' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_IsClanOfficialGameGroup");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_IsClanOfficialGameGroup");
        LOG_TRACE("{} -> 'SteamAPI_ISteamFriends_IsClanOfficialGameGroup' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_IsClanPublic");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_IsClanPublic");
        LOG_TRACE("{} -> 'SteamAPI_ISteamFriends_IsClanPublic' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_IsFollowing");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_IsFollowing");
        LOG_TRACE("{} -> 'SteamAPI_ISteamFriends_IsFollowing' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_IsUserInSource");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_IsUserInSource");
        LOG_TRACE("{} -> 'SteamAPI_ISteamFriends_IsUserInSource' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_JoinClanChatRoom");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_JoinClanChatRoom");
        LOG_TRACE("{} -> 'SteamAPI_ISteamFriends_JoinClanChatRoom' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_LeaveClanChatRoom");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_LeaveClanChatRoom");
        LOG_TRACE("{} -> 'SteamAPI_ISteamFriends_LeaveClanChatRoom' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_OpenClanChatWindowInSteam");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_OpenClanChatWindowInSteam");
        LOG_TRACE("{} -> 'SteamAPI_ISteamFriends_OpenClanChatWindowInSteam' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_RegisterProtocolInOverlayBrowser");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_RegisterProtocolInOverlayBrowser");
        LOG_TRACE("{} -> 'SteamAPI_ISteamFriends_RegisterProtocolInOverlayBrowser' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_ReplyToFriendMessage");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_ReplyToFriendMessage");
        LOG_TRACE("{} -> 'SteamAPI_ISteamFriends_ReplyToFriendMessage' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_RequestClanOfficerList");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_RequestClanOfficerList");
        LOG_TRACE("{} -> 'SteamAPI_ISteamFriends_RequestClanOfficerList' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_RequestEquippedProfileItems");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_RequestEquippedProfileItems");
        LOG_TRACE("{} -> 'SteamAPI_ISteamFriends_RequestEquippedProfileItems' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_RequestFriendRichPresence");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_RequestFriendRichPresence");
        LOG_TRACE("{} -> 'SteamAPI_ISteamFriends_RequestFriendRichPresence' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_RequestUserInformation");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_RequestUserInformation");
        LOG_TRACE("{} -> 'SteamAPI_ISteamFriends_RequestUserInformation' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_SendClanChatMessage");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_SendClanChatMessage");
        LOG_TRACE("{} -> 'SteamAPI_ISteamFriends_SendClanChatMessage' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_SetInGameVoiceSpeaking");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_SetInGameVoiceSpeaking");
        LOG_TRACE("{} -> 'SteamAPI_ISteamFriends_SetInGameVoiceSpeaking' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_SetListenForFriendsMessages");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_SetListenForFriendsMessages");
        LOG_TRACE("{} -> 'SteamAPI_ISteamFriends_SetListenForFriendsMessages' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_SetPersonaName");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_SetPersonaName");
        LOG_TRACE("{} -> 'SteamAPI_ISteamFriends_SetPersonaName' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_SetPlayedWith");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_SetPlayedWith");
        LOG_TRACE("{} -> 'SteamAPI_ISteamFriends_SetPlayedWith' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_SetRichPresence");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_SetRichPresence");
        LOG_TRACE("{} -> 'SteamAPI_ISteamFriends_SetRichPresence' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameSearch_AcceptGame");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameSearch_AcceptGame");
        LOG_TRACE("{} -> 'SteamAPI_ISteamGameSearch_AcceptGame' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameSearch_AddGameSearchParams");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameSearch_AddGameSearchParams");
        LOG_TRACE("{} -> 'SteamAPI_ISteamGameSearch_AddGameSearchParams' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameSearch_CancelRequestPlayersForGame");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameSearch_CancelRequestPlayersForGame");
        LOG_TRACE("{} -> 'SteamAPI_ISteamGameSearch_CancelRequestPlayersForGame' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameSearch_DeclineGame");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameSearch_DeclineGame");
        LOG_TRACE("{} -> 'SteamAPI_ISteamGameSearch_DeclineGame' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameSearch_EndGame");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameSearch_EndGame");
        LOG_TRACE("{} -> 'SteamAPI_ISteamGameSearch_EndGame' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameSearch_EndGameSearch");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameSearch_EndGameSearch");
        LOG_TRACE("{} -> 'SteamAPI_ISteamGameSearch_EndGameSearch' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameSearch_HostConfirmGameStart");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameSearch_HostConfirmGameStart");
        LOG_TRACE("{} -> 'SteamAPI_ISteamGameSearch_HostConfirmGameStart' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameSearch_RequestPlayersForGame");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameSearch_RequestPlayersForGame");
        LOG_TRACE("{} -> 'SteamAPI_ISteamGameSearch_RequestPlayersForGame' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameSearch_RetrieveConnectionDetails");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameSearch_RetrieveConnectionDetails");
        LOG_TRACE("{} -> 'SteamAPI_ISteamGameSearch_RetrieveConnectionDetails' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameSearch_SearchForGameSolo");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameSearch_SearchForGameSolo");
        LOG_TRACE("{} -> 'SteamAPI_ISteamGameSearch_SearchForGameSolo' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameSearch_SearchForGameWithLobby");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameSearch_SearchForGameWithLobby");
        LOG_TRACE("{} -> 'SteamAPI_ISteamGameSearch_SearchForGameWithLobby' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameSearch_SetConnectionDetails");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameSearch_SetConnectionDetails");
        LOG_TRACE("{} -> 'SteamAPI_ISteamGameSearch_SetConnectionDetails' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameSearch_SetGameHostParams");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameSearch_SetGameHostParams");
        LOG_TRACE("{} -> 'SteamAPI_ISteamGameSearch_SetGameHostParams' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameSearch_SubmitPlayerResult");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameSearch_SubmitPlayerResult");
        LOG_TRACE("{} -> 'SteamAPI_ISteamGameSearch_SubmitPlayerResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServerStats_ClearUserAchievement");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServerStats_ClearUserAchievement");
        LOG_TRACE("{} -> 'SteamAPI_ISteamGameServerStats_ClearUserAchievement' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServerStats_GetUserAchievement");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServerStats_GetUserAchievement");
        LOG_TRACE("{} -> 'SteamAPI_ISteamGameServerStats_GetUserAchievement' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServerStats_GetUserStat");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServerStats_GetUserStat");
        LOG_TRACE("{} -> 'SteamAPI_ISteamGameServerStats_GetUserStat' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServerStats_GetUserStat0");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServerStats_GetUserStat0");
        LOG_TRACE("{} -> 'SteamAPI_ISteamGameServerStats_GetUserStat0' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServerStats_GetUserStatFloat");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServerStats_GetUserStatFloat");
        LOG_TRACE("{} -> 'SteamAPI_ISteamGameServerStats_GetUserStatFloat' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServerStats_GetUserStatInt32");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServerStats_GetUserStatInt32");
        LOG_TRACE("{} -> 'SteamAPI_ISteamGameServerStats_GetUserStatInt32' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServerStats_RequestUserStats");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServerStats_RequestUserStats");
        LOG_TRACE("{} -> 'SteamAPI_ISteamGameServerStats_RequestUserStats' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServerStats_SetUserAchievement");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServerStats_SetUserAchievement");
        LOG_TRACE("{} -> 'SteamAPI_ISteamGameServerStats_SetUserAchievement' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServerStats_SetUserStat");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServerStats_SetUserStat");
        LOG_TRACE("{} -> 'SteamAPI_ISteamGameServerStats_SetUserStat' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServerStats_SetUserStat0");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServerStats_SetUserStat0");
        LOG_TRACE("{} -> 'SteamAPI_ISteamGameServerStats_SetUserStat0' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServerStats_SetUserStatFloat");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServerStats_SetUserStatFloat");
        LOG_TRACE("{} -> 'SteamAPI_ISteamGameServerStats_SetUserStatFloat' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServerStats_SetUserStatInt32");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServerStats_SetUserStatInt32");
        LOG_TRACE("{} -> 'SteamAPI_ISteamGameServerStats_SetUserStatInt32' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServerStats_StoreUserStats");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServerStats_StoreUserStats");
        LOG_TRACE("{} -> 'SteamAPI_ISteamGameServerStats_StoreUserStats' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServerStats_UpdateUserAvgRateStat");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServerStats_UpdateUserAvgRateStat");
        LOG_TRACE("{} -> 'SteamAPI_ISteamGameServerStats_UpdateUserAvgRateStat' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_AssociateWithClan");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_AssociateWithClan");
        LOG_TRACE("{} -> 'SteamAPI_ISteamGameServer_AssociateWithClan' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_BLoggedOn");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_BLoggedOn");
        LOG_TRACE("{} -> 'SteamAPI_ISteamGameServer_BLoggedOn' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_BSecure");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_BSecure");
        LOG_TRACE("{} -> 'SteamAPI_ISteamGameServer_BSecure' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_BUpdateUserData");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_BUpdateUserData");
        LOG_TRACE("{} -> 'SteamAPI_ISteamGameServer_BUpdateUserData' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_BeginAuthSession");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_BeginAuthSession");
        LOG_TRACE("{} -> 'SteamAPI_ISteamGameServer_BeginAuthSession' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_CancelAuthTicket");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_CancelAuthTicket");
        LOG_TRACE("{} -> 'SteamAPI_ISteamGameServer_CancelAuthTicket' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_ClearAllKeyValues");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_ClearAllKeyValues");
        LOG_TRACE("{} -> 'SteamAPI_ISteamGameServer_ClearAllKeyValues' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_ComputeNewPlayerCompatibility");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_ComputeNewPlayerCompatibility");
        LOG_TRACE("{} -> 'SteamAPI_ISteamGameServer_ComputeNewPlayerCompatibility' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_CreateUnauthenticatedUserConnection");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_CreateUnauthenticatedUserConnection");
        LOG_TRACE("{} -> 'SteamAPI_ISteamGameServer_CreateUnauthenticatedUserConnection' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_EnableHeartbeats");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_EnableHeartbeats");
        LOG_TRACE("{} -> 'SteamAPI_ISteamGameServer_EnableHeartbeats' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_EndAuthSession");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_EndAuthSession");
        LOG_TRACE("{} -> 'SteamAPI_ISteamGameServer_EndAuthSession' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_ForceHeartbeat");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_ForceHeartbeat");
        LOG_TRACE("{} -> 'SteamAPI_ISteamGameServer_ForceHeartbeat' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_GetAuthSessionTicket");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_GetAuthSessionTicket");
        LOG_TRACE("{} -> 'SteamAPI_ISteamGameServer_GetAuthSessionTicket' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_GetGameplayStats");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_GetGameplayStats");
        LOG_TRACE("{} -> 'SteamAPI_ISteamGameServer_GetGameplayStats' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_GetNextOutgoingPacket");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_GetNextOutgoingPacket");
        LOG_TRACE("{} -> 'SteamAPI_ISteamGameServer_GetNextOutgoingPacket' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_GetPublicIP");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_GetPublicIP");
        LOG_TRACE("{} -> 'SteamAPI_ISteamGameServer_GetPublicIP' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_GetServerReputation");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_GetServerReputation");
        LOG_TRACE("{} -> 'SteamAPI_ISteamGameServer_GetServerReputation' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_GetSteamID");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_GetSteamID");
        LOG_TRACE("{} -> 'SteamAPI_ISteamGameServer_GetSteamID' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_HandleIncomingPacket");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_HandleIncomingPacket");
        LOG_TRACE("{} -> 'SteamAPI_ISteamGameServer_HandleIncomingPacket' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_InitGameServer");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_InitGameServer");
        LOG_TRACE("{} -> 'SteamAPI_ISteamGameServer_InitGameServer' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_LogOff");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_LogOff");
        LOG_TRACE("{} -> 'SteamAPI_ISteamGameServer_LogOff' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_LogOn");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_LogOn");
        LOG_TRACE("{} -> 'SteamAPI_ISteamGameServer_LogOn' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_LogOnAnonymous");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_LogOnAnonymous");
        LOG_TRACE("{} -> 'SteamAPI_ISteamGameServer_LogOnAnonymous' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_RequestUserGroupStatus");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_RequestUserGroupStatus");
        LOG_TRACE("{} -> 'SteamAPI_ISteamGameServer_RequestUserGroupStatus' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_SendUserConnectAndAuthenticate");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_SendUserConnectAndAuthenticate");
        LOG_TRACE("{} -> 'SteamAPI_ISteamGameServer_SendUserConnectAndAuthenticate' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_SendUserConnectAndAuthenticate_DEPRECATED");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_SendUserConnectAndAuthenticate_DEPRECATED");
        LOG_TRACE("{} -> 'SteamAPI_ISteamGameServer_SendUserConnectAndAuthenticate_DEPRECATED' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_SendUserDisconnect");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_SendUserDisconnect");
        LOG_TRACE("{} -> 'SteamAPI_ISteamGameServer_SendUserDisconnect' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_SendUserDisconnect_DEPRECATED");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_SendUserDisconnect_DEPRECATED");
        LOG_TRACE("{} -> 'SteamAPI_ISteamGameServer_SendUserDisconnect_DEPRECATED' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_SetAdvertiseServerActive");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_SetAdvertiseServerActive");
        LOG_TRACE("{} -> 'SteamAPI_ISteamGameServer_SetAdvertiseServerActive' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_SetBotPlayerCount");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_SetBotPlayerCount");
        LOG_TRACE("{} -> 'SteamAPI_ISteamGameServer_SetBotPlayerCount' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_SetDedicatedServer");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_SetDedicatedServer");
        LOG_TRACE("{} -> 'SteamAPI_ISteamGameServer_SetDedicatedServer' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_SetGameData");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_SetGameData");
        LOG_TRACE("{} -> 'SteamAPI_ISteamGameServer_SetGameData' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_SetGameDescription");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_SetGameDescription");
        LOG_TRACE("{} -> 'SteamAPI_ISteamGameServer_SetGameDescription' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_SetGameTags");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_SetGameTags");
        LOG_TRACE("{} -> 'SteamAPI_ISteamGameServer_SetGameTags' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_SetHeartbeatInterval");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_SetHeartbeatInterval");
        LOG_TRACE("{} -> 'SteamAPI_ISteamGameServer_SetHeartbeatInterval' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_SetKeyValue");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_SetKeyValue");
        LOG_TRACE("{} -> 'SteamAPI_ISteamGameServer_SetKeyValue' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_SetMapName");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_SetMapName");
        LOG_TRACE("{} -> 'SteamAPI_ISteamGameServer_SetMapName' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_SetMaxPlayerCount");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_SetMaxPlayerCount");
        LOG_TRACE("{} -> 'SteamAPI_ISteamGameServer_SetMaxPlayerCount' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_SetModDir");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_SetModDir");
        LOG_TRACE("{} -> 'SteamAPI_ISteamGameServer_SetModDir' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_SetPasswordProtected");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_SetPasswordProtected");
        LOG_TRACE("{} -> 'SteamAPI_ISteamGameServer_SetPasswordProtected' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_SetProduct");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_SetProduct");
        LOG_TRACE("{} -> 'SteamAPI_ISteamGameServer_SetProduct' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_SetRegion");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_SetRegion");
        LOG_TRACE("{} -> 'SteamAPI_ISteamGameServer_SetRegion' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_SetServerName");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_SetServerName");
        LOG_TRACE("{} -> 'SteamAPI_ISteamGameServer_SetServerName' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_SetSpectatorPort");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_SetSpectatorPort");
        LOG_TRACE("{} -> 'SteamAPI_ISteamGameServer_SetSpectatorPort' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_SetSpectatorServerName");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_SetSpectatorServerName");
        LOG_TRACE("{} -> 'SteamAPI_ISteamGameServer_SetSpectatorServerName' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_UserHasLicenseForApp");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_UserHasLicenseForApp");
        LOG_TRACE("{} -> 'SteamAPI_ISteamGameServer_UserHasLicenseForApp' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_WasRestartRequested");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_WasRestartRequested");
        LOG_TRACE("{} -> 'SteamAPI_ISteamGameServer_WasRestartRequested' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTMLSurface_AddHeader");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTMLSurface_AddHeader");
        LOG_TRACE("{} -> 'SteamAPI_ISteamHTMLSurface_AddHeader' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTMLSurface_AllowStartRequest");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTMLSurface_AllowStartRequest");
        LOG_TRACE("{} -> 'SteamAPI_ISteamHTMLSurface_AllowStartRequest' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTMLSurface_CopyToClipboard");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTMLSurface_CopyToClipboard");
        LOG_TRACE("{} -> 'SteamAPI_ISteamHTMLSurface_CopyToClipboard' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTMLSurface_CreateBrowser");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTMLSurface_CreateBrowser");
        LOG_TRACE("{} -> 'SteamAPI_ISteamHTMLSurface_CreateBrowser' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTMLSurface_DestructISteamHTMLSurface");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTMLSurface_DestructISteamHTMLSurface");
        LOG_TRACE("{} -> 'SteamAPI_ISteamHTMLSurface_DestructISteamHTMLSurface' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTMLSurface_ExecuteJavascript");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTMLSurface_ExecuteJavascript");
        LOG_TRACE("{} -> 'SteamAPI_ISteamHTMLSurface_ExecuteJavascript' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTMLSurface_FileLoadDialogResponse");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTMLSurface_FileLoadDialogResponse");
        LOG_TRACE("{} -> 'SteamAPI_ISteamHTMLSurface_FileLoadDialogResponse' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTMLSurface_Find");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTMLSurface_Find");
        LOG_TRACE("{} -> 'SteamAPI_ISteamHTMLSurface_Find' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTMLSurface_GetLinkAtPosition");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTMLSurface_GetLinkAtPosition");
        LOG_TRACE("{} -> 'SteamAPI_ISteamHTMLSurface_GetLinkAtPosition' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTMLSurface_GoBack");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTMLSurface_GoBack");
        LOG_TRACE("{} -> 'SteamAPI_ISteamHTMLSurface_GoBack' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTMLSurface_GoForward");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTMLSurface_GoForward");
        LOG_TRACE("{} -> 'SteamAPI_ISteamHTMLSurface_GoForward' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTMLSurface_Init");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTMLSurface_Init");
        LOG_TRACE("{} -> 'SteamAPI_ISteamHTMLSurface_Init' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTMLSurface_JSDialogResponse");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTMLSurface_JSDialogResponse");
        LOG_TRACE("{} -> 'SteamAPI_ISteamHTMLSurface_JSDialogResponse' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTMLSurface_KeyChar");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTMLSurface_KeyChar");
        LOG_TRACE("{} -> 'SteamAPI_ISteamHTMLSurface_KeyChar' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTMLSurface_KeyDown");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTMLSurface_KeyDown");
        LOG_TRACE("{} -> 'SteamAPI_ISteamHTMLSurface_KeyDown' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTMLSurface_KeyUp");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTMLSurface_KeyUp");
        LOG_TRACE("{} -> 'SteamAPI_ISteamHTMLSurface_KeyUp' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTMLSurface_LoadURL");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTMLSurface_LoadURL");
        LOG_TRACE("{} -> 'SteamAPI_ISteamHTMLSurface_LoadURL' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTMLSurface_MouseDoubleClick");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTMLSurface_MouseDoubleClick");
        LOG_TRACE("{} -> 'SteamAPI_ISteamHTMLSurface_MouseDoubleClick' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTMLSurface_MouseDown");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTMLSurface_MouseDown");
        LOG_TRACE("{} -> 'SteamAPI_ISteamHTMLSurface_MouseDown' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTMLSurface_MouseMove");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTMLSurface_MouseMove");
        LOG_TRACE("{} -> 'SteamAPI_ISteamHTMLSurface_MouseMove' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTMLSurface_MouseUp");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTMLSurface_MouseUp");
        LOG_TRACE("{} -> 'SteamAPI_ISteamHTMLSurface_MouseUp' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTMLSurface_MouseWheel");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTMLSurface_MouseWheel");
        LOG_TRACE("{} -> 'SteamAPI_ISteamHTMLSurface_MouseWheel' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTMLSurface_OpenDeveloperTools");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTMLSurface_OpenDeveloperTools");
        LOG_TRACE("{} -> 'SteamAPI_ISteamHTMLSurface_OpenDeveloperTools' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTMLSurface_PasteFromClipboard");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTMLSurface_PasteFromClipboard");
        LOG_TRACE("{} -> 'SteamAPI_ISteamHTMLSurface_PasteFromClipboard' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTMLSurface_Reload");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTMLSurface_Reload");
        LOG_TRACE("{} -> 'SteamAPI_ISteamHTMLSurface_Reload' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTMLSurface_RemoveBrowser");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTMLSurface_RemoveBrowser");
        LOG_TRACE("{} -> 'SteamAPI_ISteamHTMLSurface_RemoveBrowser' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTMLSurface_SetBackgroundMode");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTMLSurface_SetBackgroundMode");
        LOG_TRACE("{} -> 'SteamAPI_ISteamHTMLSurface_SetBackgroundMode' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTMLSurface_SetCookie");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTMLSurface_SetCookie");
        LOG_TRACE("{} -> 'SteamAPI_ISteamHTMLSurface_SetCookie' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTMLSurface_SetDPIScalingFactor");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTMLSurface_SetDPIScalingFactor");
        LOG_TRACE("{} -> 'SteamAPI_ISteamHTMLSurface_SetDPIScalingFactor' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTMLSurface_SetHorizontalScroll");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTMLSurface_SetHorizontalScroll");
        LOG_TRACE("{} -> 'SteamAPI_ISteamHTMLSurface_SetHorizontalScroll' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTMLSurface_SetKeyFocus");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTMLSurface_SetKeyFocus");
        LOG_TRACE("{} -> 'SteamAPI_ISteamHTMLSurface_SetKeyFocus' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTMLSurface_SetPageScaleFactor");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTMLSurface_SetPageScaleFactor");
        LOG_TRACE("{} -> 'SteamAPI_ISteamHTMLSurface_SetPageScaleFactor' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTMLSurface_SetSize");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTMLSurface_SetSize");
        LOG_TRACE("{} -> 'SteamAPI_ISteamHTMLSurface_SetSize' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTMLSurface_SetVerticalScroll");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTMLSurface_SetVerticalScroll");
        LOG_TRACE("{} -> 'SteamAPI_ISteamHTMLSurface_SetVerticalScroll' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTMLSurface_Shutdown");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTMLSurface_Shutdown");
        LOG_TRACE("{} -> 'SteamAPI_ISteamHTMLSurface_Shutdown' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTMLSurface_StopFind");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTMLSurface_StopFind");
        LOG_TRACE("{} -> 'SteamAPI_ISteamHTMLSurface_StopFind' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTMLSurface_StopLoad");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTMLSurface_StopLoad");
        LOG_TRACE("{} -> 'SteamAPI_ISteamHTMLSurface_StopLoad' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTMLSurface_ViewSource");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTMLSurface_ViewSource");
        LOG_TRACE("{} -> 'SteamAPI_ISteamHTMLSurface_ViewSource' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTTP_CreateCookieContainer");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTTP_CreateCookieContainer");
        LOG_TRACE("{} -> 'SteamAPI_ISteamHTTP_CreateCookieContainer' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTTP_CreateHTTPRequest");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTTP_CreateHTTPRequest");
        LOG_TRACE("{} -> 'SteamAPI_ISteamHTTP_CreateHTTPRequest' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTTP_DeferHTTPRequest");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTTP_DeferHTTPRequest");
        LOG_TRACE("{} -> 'SteamAPI_ISteamHTTP_DeferHTTPRequest' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTTP_GetHTTPDownloadProgressPct");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTTP_GetHTTPDownloadProgressPct");
        LOG_TRACE("{} -> 'SteamAPI_ISteamHTTP_GetHTTPDownloadProgressPct' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTTP_GetHTTPRequestWasTimedOut");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTTP_GetHTTPRequestWasTimedOut");
        LOG_TRACE("{} -> 'SteamAPI_ISteamHTTP_GetHTTPRequestWasTimedOut' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTTP_GetHTTPResponseBodyData");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTTP_GetHTTPResponseBodyData");
        LOG_TRACE("{} -> 'SteamAPI_ISteamHTTP_GetHTTPResponseBodyData' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTTP_GetHTTPResponseBodySize");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTTP_GetHTTPResponseBodySize");
        LOG_TRACE("{} -> 'SteamAPI_ISteamHTTP_GetHTTPResponseBodySize' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTTP_GetHTTPResponseHeaderSize");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTTP_GetHTTPResponseHeaderSize");
        LOG_TRACE("{} -> 'SteamAPI_ISteamHTTP_GetHTTPResponseHeaderSize' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTTP_GetHTTPResponseHeaderValue");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTTP_GetHTTPResponseHeaderValue");
        LOG_TRACE("{} -> 'SteamAPI_ISteamHTTP_GetHTTPResponseHeaderValue' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTTP_GetHTTPStreamingResponseBodyData");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTTP_GetHTTPStreamingResponseBodyData");
        LOG_TRACE("{} -> 'SteamAPI_ISteamHTTP_GetHTTPStreamingResponseBodyData' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTTP_PrioritizeHTTPRequest");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTTP_PrioritizeHTTPRequest");
        LOG_TRACE("{} -> 'SteamAPI_ISteamHTTP_PrioritizeHTTPRequest' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTTP_ReleaseCookieContainer");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTTP_ReleaseCookieContainer");
        LOG_TRACE("{} -> 'SteamAPI_ISteamHTTP_ReleaseCookieContainer' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTTP_ReleaseHTTPRequest");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTTP_ReleaseHTTPRequest");
        LOG_TRACE("{} -> 'SteamAPI_ISteamHTTP_ReleaseHTTPRequest' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTTP_SendHTTPRequest");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTTP_SendHTTPRequest");
        LOG_TRACE("{} -> 'SteamAPI_ISteamHTTP_SendHTTPRequest' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTTP_SendHTTPRequestAndStreamResponse");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTTP_SendHTTPRequestAndStreamResponse");
        LOG_TRACE("{} -> 'SteamAPI_ISteamHTTP_SendHTTPRequestAndStreamResponse' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTTP_SetCookie");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTTP_SetCookie");
        LOG_TRACE("{} -> 'SteamAPI_ISteamHTTP_SetCookie' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTTP_SetHTTPRequestAbsoluteTimeoutMS");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTTP_SetHTTPRequestAbsoluteTimeoutMS");
        LOG_TRACE("{} -> 'SteamAPI_ISteamHTTP_SetHTTPRequestAbsoluteTimeoutMS' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTTP_SetHTTPRequestContextValue");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTTP_SetHTTPRequestContextValue");
        LOG_TRACE("{} -> 'SteamAPI_ISteamHTTP_SetHTTPRequestContextValue' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTTP_SetHTTPRequestCookieContainer");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTTP_SetHTTPRequestCookieContainer");
        LOG_TRACE("{} -> 'SteamAPI_ISteamHTTP_SetHTTPRequestCookieContainer' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTTP_SetHTTPRequestGetOrPostParameter");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTTP_SetHTTPRequestGetOrPostParameter");
        LOG_TRACE("{} -> 'SteamAPI_ISteamHTTP_SetHTTPRequestGetOrPostParameter' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTTP_SetHTTPRequestHeaderValue");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTTP_SetHTTPRequestHeaderValue");
        LOG_TRACE("{} -> 'SteamAPI_ISteamHTTP_SetHTTPRequestHeaderValue' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTTP_SetHTTPRequestNetworkActivityTimeout");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTTP_SetHTTPRequestNetworkActivityTimeout");
        LOG_TRACE("{} -> 'SteamAPI_ISteamHTTP_SetHTTPRequestNetworkActivityTimeout' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTTP_SetHTTPRequestRawPostBody");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTTP_SetHTTPRequestRawPostBody");
        LOG_TRACE("{} -> 'SteamAPI_ISteamHTTP_SetHTTPRequestRawPostBody' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTTP_SetHTTPRequestRequiresVerifiedCertificate");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTTP_SetHTTPRequestRequiresVerifiedCertificate");
        LOG_TRACE("{} -> 'SteamAPI_ISteamHTTP_SetHTTPRequestRequiresVerifiedCertificate' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTTP_SetHTTPRequestUserAgentInfo");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTTP_SetHTTPRequestUserAgentInfo");
        LOG_TRACE("{} -> 'SteamAPI_ISteamHTTP_SetHTTPRequestUserAgentInfo' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_ActivateActionSet");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_ActivateActionSet");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInput_ActivateActionSet' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_ActivateActionSetLayer");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_ActivateActionSetLayer");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInput_ActivateActionSetLayer' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_BNewDataAvailable");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_BNewDataAvailable");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInput_BNewDataAvailable' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_BWaitForData");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_BWaitForData");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInput_BWaitForData' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_DeactivateActionSetLayer");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_DeactivateActionSetLayer");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInput_DeactivateActionSetLayer' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_DeactivateAllActionSetLayers");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_DeactivateAllActionSetLayers");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInput_DeactivateAllActionSetLayers' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_EnableActionEventCallbacks");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_EnableActionEventCallbacks");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInput_EnableActionEventCallbacks' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_EnableDeviceCallbacks");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_EnableDeviceCallbacks");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInput_EnableDeviceCallbacks' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_GetActionOriginFromXboxOrigin");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_GetActionOriginFromXboxOrigin");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInput_GetActionOriginFromXboxOrigin' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_GetActionSetHandle");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_GetActionSetHandle");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInput_GetActionSetHandle' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_GetActiveActionSetLayers");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_GetActiveActionSetLayers");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInput_GetActiveActionSetLayers' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_GetAnalogActionData");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_GetAnalogActionData");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInput_GetAnalogActionData' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_GetAnalogActionHandle");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_GetAnalogActionHandle");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInput_GetAnalogActionHandle' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_GetAnalogActionOrigins");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_GetAnalogActionOrigins");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInput_GetAnalogActionOrigins' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_GetConnectedControllers");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_GetConnectedControllers");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInput_GetConnectedControllers' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_GetControllerForGamepadIndex");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_GetControllerForGamepadIndex");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInput_GetControllerForGamepadIndex' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_GetCurrentActionSet");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_GetCurrentActionSet");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInput_GetCurrentActionSet' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_GetDeviceBindingRevision");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_GetDeviceBindingRevision");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInput_GetDeviceBindingRevision' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_GetDigitalActionData");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_GetDigitalActionData");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInput_GetDigitalActionData' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_GetDigitalActionHandle");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_GetDigitalActionHandle");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInput_GetDigitalActionHandle' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_GetDigitalActionOrigins");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_GetDigitalActionOrigins");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInput_GetDigitalActionOrigins' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_GetGamepadIndexForController");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_GetGamepadIndexForController");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInput_GetGamepadIndexForController' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_GetGlyphForActionOrigin");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_GetGlyphForActionOrigin");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInput_GetGlyphForActionOrigin' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_GetGlyphForActionOrigin_Legacy");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_GetGlyphForActionOrigin_Legacy");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInput_GetGlyphForActionOrigin_Legacy' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_GetGlyphForXboxOrigin");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_GetGlyphForXboxOrigin");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInput_GetGlyphForXboxOrigin' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_GetGlyphPNGForActionOrigin");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_GetGlyphPNGForActionOrigin");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInput_GetGlyphPNGForActionOrigin' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_GetGlyphSVGForActionOrigin");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_GetGlyphSVGForActionOrigin");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInput_GetGlyphSVGForActionOrigin' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_GetInputTypeForHandle");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_GetInputTypeForHandle");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInput_GetInputTypeForHandle' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_GetMotionData");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_GetMotionData");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInput_GetMotionData' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_GetRemotePlaySessionID");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_GetRemotePlaySessionID");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInput_GetRemotePlaySessionID' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_GetSessionInputConfigurationSettings");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_GetSessionInputConfigurationSettings");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInput_GetSessionInputConfigurationSettings' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_GetStringForActionOrigin");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_GetStringForActionOrigin");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInput_GetStringForActionOrigin' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_GetStringForAnalogActionName");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_GetStringForAnalogActionName");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInput_GetStringForAnalogActionName' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_GetStringForDigitalActionName");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_GetStringForDigitalActionName");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInput_GetStringForDigitalActionName' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_GetStringForXboxOrigin");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_GetStringForXboxOrigin");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInput_GetStringForXboxOrigin' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_Init");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_Init");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInput_Init' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_Legacy_TriggerHapticPulse");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_Legacy_TriggerHapticPulse");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInput_Legacy_TriggerHapticPulse' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_Legacy_TriggerRepeatedHapticPulse");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_Legacy_TriggerRepeatedHapticPulse");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInput_Legacy_TriggerRepeatedHapticPulse' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_RunFrame");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_RunFrame");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInput_RunFrame' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_SetDualSenseTriggerEffect");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_SetDualSenseTriggerEffect");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInput_SetDualSenseTriggerEffect' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_SetInputActionManifestFilePath");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_SetInputActionManifestFilePath");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInput_SetInputActionManifestFilePath' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_SetLEDColor");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_SetLEDColor");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInput_SetLEDColor' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_ShowBindingPanel");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_ShowBindingPanel");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInput_ShowBindingPanel' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_Shutdown");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_Shutdown");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInput_Shutdown' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_StopAnalogActionMomentum");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_StopAnalogActionMomentum");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInput_StopAnalogActionMomentum' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_TranslateActionOrigin");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_TranslateActionOrigin");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInput_TranslateActionOrigin' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_TriggerHapticPulse");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_TriggerHapticPulse");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInput_TriggerHapticPulse' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_TriggerRepeatedHapticPulse");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_TriggerRepeatedHapticPulse");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInput_TriggerRepeatedHapticPulse' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_TriggerSimpleHapticEvent");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_TriggerSimpleHapticEvent");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInput_TriggerSimpleHapticEvent' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_TriggerVibration");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_TriggerVibration");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInput_TriggerVibration' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_TriggerVibrationExtended");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_TriggerVibrationExtended");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInput_TriggerVibrationExtended' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInventory_AddPromoItem");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInventory_AddPromoItem");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInventory_AddPromoItem' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInventory_AddPromoItems");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInventory_AddPromoItems");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInventory_AddPromoItems' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInventory_CheckResultSteamID");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInventory_CheckResultSteamID");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInventory_CheckResultSteamID' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInventory_ConsumeItem");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInventory_ConsumeItem");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInventory_ConsumeItem' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInventory_DeserializeResult");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInventory_DeserializeResult");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInventory_DeserializeResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInventory_DestroyResult");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInventory_DestroyResult");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInventory_DestroyResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInventory_ExchangeItems");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInventory_ExchangeItems");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInventory_ExchangeItems' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInventory_GenerateItems");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInventory_GenerateItems");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInventory_GenerateItems' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInventory_GetAllItems");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInventory_GetAllItems");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInventory_GetAllItems' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInventory_GetEligiblePromoItemDefinitionIDs");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInventory_GetEligiblePromoItemDefinitionIDs");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInventory_GetEligiblePromoItemDefinitionIDs' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInventory_GetItemDefinitionIDs");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInventory_GetItemDefinitionIDs");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInventory_GetItemDefinitionIDs' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInventory_GetItemDefinitionProperty");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInventory_GetItemDefinitionProperty");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInventory_GetItemDefinitionProperty' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInventory_GetItemPrice");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInventory_GetItemPrice");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInventory_GetItemPrice' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInventory_GetItemsByID");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInventory_GetItemsByID");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInventory_GetItemsByID' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInventory_GetItemsWithPrices");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInventory_GetItemsWithPrices");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInventory_GetItemsWithPrices' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInventory_GetNumItemsWithPrices");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInventory_GetNumItemsWithPrices");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInventory_GetNumItemsWithPrices' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInventory_GetResultItemProperty");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInventory_GetResultItemProperty");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInventory_GetResultItemProperty' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInventory_GetResultItems");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInventory_GetResultItems");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInventory_GetResultItems' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInventory_GetResultStatus");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInventory_GetResultStatus");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInventory_GetResultStatus' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInventory_GetResultTimestamp");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInventory_GetResultTimestamp");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInventory_GetResultTimestamp' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInventory_GrantPromoItems");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInventory_GrantPromoItems");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInventory_GrantPromoItems' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInventory_InspectItem");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInventory_InspectItem");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInventory_InspectItem' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInventory_LoadItemDefinitions");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInventory_LoadItemDefinitions");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInventory_LoadItemDefinitions' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInventory_RemoveProperty");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInventory_RemoveProperty");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInventory_RemoveProperty' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInventory_RequestEligiblePromoItemDefinitionsIDs");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInventory_RequestEligiblePromoItemDefinitionsIDs");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInventory_RequestEligiblePromoItemDefinitionsIDs' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInventory_RequestPrices");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInventory_RequestPrices");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInventory_RequestPrices' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInventory_SendItemDropHeartbeat");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInventory_SendItemDropHeartbeat");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInventory_SendItemDropHeartbeat' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInventory_SerializeResult");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInventory_SerializeResult");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInventory_SerializeResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInventory_SetProperty");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInventory_SetProperty");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInventory_SetProperty' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInventory_SetProperty0");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInventory_SetProperty0");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInventory_SetProperty0' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInventory_SetProperty1");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInventory_SetProperty1");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInventory_SetProperty1' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInventory_SetProperty2");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInventory_SetProperty2");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInventory_SetProperty2' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInventory_SetPropertyBool");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInventory_SetPropertyBool");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInventory_SetPropertyBool' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInventory_SetPropertyFloat");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInventory_SetPropertyFloat");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInventory_SetPropertyFloat' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInventory_SetPropertyInt64");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInventory_SetPropertyInt64");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInventory_SetPropertyInt64' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInventory_SetPropertyString");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInventory_SetPropertyString");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInventory_SetPropertyString' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInventory_StartPurchase");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInventory_StartPurchase");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInventory_StartPurchase' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInventory_StartUpdateProperties");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInventory_StartUpdateProperties");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInventory_StartUpdateProperties' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInventory_SubmitUpdateProperties");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInventory_SubmitUpdateProperties");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInventory_SubmitUpdateProperties' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInventory_TradeItems");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInventory_TradeItems");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInventory_TradeItems' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInventory_TransferItemQuantity");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInventory_TransferItemQuantity");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInventory_TransferItemQuantity' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInventory_TriggerItemDrop");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInventory_TriggerItemDrop");
        LOG_TRACE("{} -> 'SteamAPI_ISteamInventory_TriggerItemDrop' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmakingPingResponse_ServerFailedToRespond");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmakingPingResponse_ServerFailedToRespond");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMatchmakingPingResponse_ServerFailedToRespond' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmakingPingResponse_ServerResponded");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmakingPingResponse_ServerResponded");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMatchmakingPingResponse_ServerResponded' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmakingPlayersResponse_AddPlayerToList");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmakingPlayersResponse_AddPlayerToList");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMatchmakingPlayersResponse_AddPlayerToList' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmakingPlayersResponse_PlayersFailedToRespond");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmakingPlayersResponse_PlayersFailedToRespond");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMatchmakingPlayersResponse_PlayersFailedToRespond' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmakingPlayersResponse_PlayersRefreshComplete");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmakingPlayersResponse_PlayersRefreshComplete");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMatchmakingPlayersResponse_PlayersRefreshComplete' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmakingRulesResponse_RulesFailedToRespond");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmakingRulesResponse_RulesFailedToRespond");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMatchmakingRulesResponse_RulesFailedToRespond' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmakingRulesResponse_RulesRefreshComplete");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmakingRulesResponse_RulesRefreshComplete");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMatchmakingRulesResponse_RulesRefreshComplete' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmakingRulesResponse_RulesResponded");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmakingRulesResponse_RulesResponded");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMatchmakingRulesResponse_RulesResponded' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmakingServerListResponse_RefreshComplete");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmakingServerListResponse_RefreshComplete");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMatchmakingServerListResponse_RefreshComplete' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmakingServerListResponse_ServerFailedToRespond");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmakingServerListResponse_ServerFailedToRespond");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMatchmakingServerListResponse_ServerFailedToRespond' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmakingServerListResponse_ServerResponded");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmakingServerListResponse_ServerResponded");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMatchmakingServerListResponse_ServerResponded' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmakingServers_CancelQuery");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmakingServers_CancelQuery");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMatchmakingServers_CancelQuery' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmakingServers_CancelServerQuery");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmakingServers_CancelServerQuery");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMatchmakingServers_CancelServerQuery' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmakingServers_GetServerCount");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmakingServers_GetServerCount");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMatchmakingServers_GetServerCount' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmakingServers_GetServerDetails");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmakingServers_GetServerDetails");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMatchmakingServers_GetServerDetails' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmakingServers_IsRefreshing");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmakingServers_IsRefreshing");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMatchmakingServers_IsRefreshing' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmakingServers_PingServer");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmakingServers_PingServer");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMatchmakingServers_PingServer' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmakingServers_PlayerDetails");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmakingServers_PlayerDetails");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMatchmakingServers_PlayerDetails' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmakingServers_RefreshQuery");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmakingServers_RefreshQuery");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMatchmakingServers_RefreshQuery' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmakingServers_RefreshServer");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmakingServers_RefreshServer");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMatchmakingServers_RefreshServer' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmakingServers_ReleaseRequest");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmakingServers_ReleaseRequest");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMatchmakingServers_ReleaseRequest' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmakingServers_RequestFavoritesServerList");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmakingServers_RequestFavoritesServerList");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMatchmakingServers_RequestFavoritesServerList' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmakingServers_RequestFriendsServerList");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmakingServers_RequestFriendsServerList");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMatchmakingServers_RequestFriendsServerList' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmakingServers_RequestHistoryServerList");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmakingServers_RequestHistoryServerList");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMatchmakingServers_RequestHistoryServerList' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmakingServers_RequestInternetServerList");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmakingServers_RequestInternetServerList");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMatchmakingServers_RequestInternetServerList' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmakingServers_RequestLANServerList");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmakingServers_RequestLANServerList");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMatchmakingServers_RequestLANServerList' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmakingServers_RequestSpectatorServerList");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmakingServers_RequestSpectatorServerList");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMatchmakingServers_RequestSpectatorServerList' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmakingServers_ServerRules");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmakingServers_ServerRules");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMatchmakingServers_ServerRules' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmaking_AddFavoriteGame");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmaking_AddFavoriteGame");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMatchmaking_AddFavoriteGame' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmaking_AddRequestLobbyListCompatibleMembersFilter");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmaking_AddRequestLobbyListCompatibleMembersFilter");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMatchmaking_AddRequestLobbyListCompatibleMembersFilter' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmaking_AddRequestLobbyListDistanceFilter");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmaking_AddRequestLobbyListDistanceFilter");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMatchmaking_AddRequestLobbyListDistanceFilter' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmaking_AddRequestLobbyListFilterSlotsAvailable");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmaking_AddRequestLobbyListFilterSlotsAvailable");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMatchmaking_AddRequestLobbyListFilterSlotsAvailable' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmaking_AddRequestLobbyListNearValueFilter");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmaking_AddRequestLobbyListNearValueFilter");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMatchmaking_AddRequestLobbyListNearValueFilter' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmaking_AddRequestLobbyListNumericalFilter");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmaking_AddRequestLobbyListNumericalFilter");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMatchmaking_AddRequestLobbyListNumericalFilter' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmaking_AddRequestLobbyListResultCountFilter");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmaking_AddRequestLobbyListResultCountFilter");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMatchmaking_AddRequestLobbyListResultCountFilter' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmaking_AddRequestLobbyListStringFilter");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmaking_AddRequestLobbyListStringFilter");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMatchmaking_AddRequestLobbyListStringFilter' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmaking_CreateLobby");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmaking_CreateLobby");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMatchmaking_CreateLobby' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmaking_DeleteLobbyData");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmaking_DeleteLobbyData");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMatchmaking_DeleteLobbyData' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmaking_GetFavoriteGame");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmaking_GetFavoriteGame");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMatchmaking_GetFavoriteGame' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmaking_GetFavoriteGameCount");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmaking_GetFavoriteGameCount");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMatchmaking_GetFavoriteGameCount' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmaking_GetLobbyByIndex");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmaking_GetLobbyByIndex");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMatchmaking_GetLobbyByIndex' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmaking_GetLobbyChatEntry");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmaking_GetLobbyChatEntry");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMatchmaking_GetLobbyChatEntry' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmaking_GetLobbyData");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmaking_GetLobbyData");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMatchmaking_GetLobbyData' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmaking_GetLobbyDataByIndex");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmaking_GetLobbyDataByIndex");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMatchmaking_GetLobbyDataByIndex' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmaking_GetLobbyDataCount");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmaking_GetLobbyDataCount");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMatchmaking_GetLobbyDataCount' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmaking_GetLobbyGameServer");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmaking_GetLobbyGameServer");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMatchmaking_GetLobbyGameServer' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmaking_GetLobbyMemberByIndex");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmaking_GetLobbyMemberByIndex");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMatchmaking_GetLobbyMemberByIndex' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmaking_GetLobbyMemberData");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmaking_GetLobbyMemberData");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMatchmaking_GetLobbyMemberData' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmaking_GetLobbyMemberLimit");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmaking_GetLobbyMemberLimit");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMatchmaking_GetLobbyMemberLimit' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmaking_GetLobbyOwner");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmaking_GetLobbyOwner");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMatchmaking_GetLobbyOwner' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmaking_GetNumLobbyMembers");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmaking_GetNumLobbyMembers");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMatchmaking_GetNumLobbyMembers' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmaking_InviteUserToLobby");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmaking_InviteUserToLobby");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMatchmaking_InviteUserToLobby' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmaking_JoinLobby");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmaking_JoinLobby");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMatchmaking_JoinLobby' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmaking_LeaveLobby");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmaking_LeaveLobby");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMatchmaking_LeaveLobby' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmaking_RemoveFavoriteGame");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmaking_RemoveFavoriteGame");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMatchmaking_RemoveFavoriteGame' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmaking_RequestLobbyData");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmaking_RequestLobbyData");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMatchmaking_RequestLobbyData' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmaking_RequestLobbyList");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmaking_RequestLobbyList");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMatchmaking_RequestLobbyList' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmaking_SendLobbyChatMsg");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmaking_SendLobbyChatMsg");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMatchmaking_SendLobbyChatMsg' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmaking_SetLinkedLobby");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmaking_SetLinkedLobby");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMatchmaking_SetLinkedLobby' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmaking_SetLobbyData");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmaking_SetLobbyData");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMatchmaking_SetLobbyData' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmaking_SetLobbyGameServer");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmaking_SetLobbyGameServer");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMatchmaking_SetLobbyGameServer' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmaking_SetLobbyJoinable");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmaking_SetLobbyJoinable");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMatchmaking_SetLobbyJoinable' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmaking_SetLobbyMemberData");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmaking_SetLobbyMemberData");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMatchmaking_SetLobbyMemberData' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmaking_SetLobbyMemberLimit");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmaking_SetLobbyMemberLimit");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMatchmaking_SetLobbyMemberLimit' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmaking_SetLobbyOwner");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmaking_SetLobbyOwner");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMatchmaking_SetLobbyOwner' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmaking_SetLobbyType");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmaking_SetLobbyType");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMatchmaking_SetLobbyType' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMusicRemote_BActivationSuccess");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMusicRemote_BActivationSuccess");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMusicRemote_BActivationSuccess' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMusicRemote_BIsCurrentMusicRemote");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMusicRemote_BIsCurrentMusicRemote");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMusicRemote_BIsCurrentMusicRemote' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMusicRemote_CurrentEntryDidChange");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMusicRemote_CurrentEntryDidChange");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMusicRemote_CurrentEntryDidChange' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMusicRemote_CurrentEntryIsAvailable");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMusicRemote_CurrentEntryIsAvailable");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMusicRemote_CurrentEntryIsAvailable' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMusicRemote_CurrentEntryWillChange");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMusicRemote_CurrentEntryWillChange");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMusicRemote_CurrentEntryWillChange' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMusicRemote_DeregisterSteamMusicRemote");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMusicRemote_DeregisterSteamMusicRemote");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMusicRemote_DeregisterSteamMusicRemote' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMusicRemote_EnableLooped");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMusicRemote_EnableLooped");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMusicRemote_EnableLooped' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMusicRemote_EnablePlayNext");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMusicRemote_EnablePlayNext");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMusicRemote_EnablePlayNext' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMusicRemote_EnablePlayPrevious");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMusicRemote_EnablePlayPrevious");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMusicRemote_EnablePlayPrevious' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMusicRemote_EnablePlaylists");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMusicRemote_EnablePlaylists");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMusicRemote_EnablePlaylists' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMusicRemote_EnableQueue");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMusicRemote_EnableQueue");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMusicRemote_EnableQueue' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMusicRemote_EnableShuffled");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMusicRemote_EnableShuffled");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMusicRemote_EnableShuffled' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMusicRemote_PlaylistDidChange");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMusicRemote_PlaylistDidChange");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMusicRemote_PlaylistDidChange' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMusicRemote_PlaylistWillChange");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMusicRemote_PlaylistWillChange");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMusicRemote_PlaylistWillChange' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMusicRemote_QueueDidChange");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMusicRemote_QueueDidChange");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMusicRemote_QueueDidChange' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMusicRemote_QueueWillChange");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMusicRemote_QueueWillChange");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMusicRemote_QueueWillChange' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMusicRemote_RegisterSteamMusicRemote");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMusicRemote_RegisterSteamMusicRemote");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMusicRemote_RegisterSteamMusicRemote' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMusicRemote_ResetPlaylistEntries");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMusicRemote_ResetPlaylistEntries");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMusicRemote_ResetPlaylistEntries' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMusicRemote_ResetQueueEntries");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMusicRemote_ResetQueueEntries");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMusicRemote_ResetQueueEntries' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMusicRemote_SetCurrentPlaylistEntry");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMusicRemote_SetCurrentPlaylistEntry");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMusicRemote_SetCurrentPlaylistEntry' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMusicRemote_SetCurrentQueueEntry");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMusicRemote_SetCurrentQueueEntry");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMusicRemote_SetCurrentQueueEntry' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMusicRemote_SetDisplayName");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMusicRemote_SetDisplayName");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMusicRemote_SetDisplayName' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMusicRemote_SetPNGIcon_64x64");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMusicRemote_SetPNGIcon_64x64");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMusicRemote_SetPNGIcon_64x64' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMusicRemote_SetPlaylistEntry");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMusicRemote_SetPlaylistEntry");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMusicRemote_SetPlaylistEntry' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMusicRemote_SetQueueEntry");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMusicRemote_SetQueueEntry");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMusicRemote_SetQueueEntry' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMusicRemote_UpdateCurrentEntryCoverArt");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMusicRemote_UpdateCurrentEntryCoverArt");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMusicRemote_UpdateCurrentEntryCoverArt' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMusicRemote_UpdateCurrentEntryElapsedSeconds");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMusicRemote_UpdateCurrentEntryElapsedSeconds");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMusicRemote_UpdateCurrentEntryElapsedSeconds' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMusicRemote_UpdateCurrentEntryText");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMusicRemote_UpdateCurrentEntryText");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMusicRemote_UpdateCurrentEntryText' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMusicRemote_UpdateLooped");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMusicRemote_UpdateLooped");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMusicRemote_UpdateLooped' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMusicRemote_UpdatePlaybackStatus");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMusicRemote_UpdatePlaybackStatus");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMusicRemote_UpdatePlaybackStatus' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMusicRemote_UpdateShuffled");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMusicRemote_UpdateShuffled");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMusicRemote_UpdateShuffled' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMusicRemote_UpdateVolume");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMusicRemote_UpdateVolume");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMusicRemote_UpdateVolume' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMusic_BIsEnabled");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMusic_BIsEnabled");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMusic_BIsEnabled' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMusic_BIsPlaying");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMusic_BIsPlaying");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMusic_BIsPlaying' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMusic_GetPlaybackStatus");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMusic_GetPlaybackStatus");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMusic_GetPlaybackStatus' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMusic_GetVolume");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMusic_GetVolume");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMusic_GetVolume' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMusic_Pause");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMusic_Pause");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMusic_Pause' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMusic_Play");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMusic_Play");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMusic_Play' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMusic_PlayNext");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMusic_PlayNext");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMusic_PlayNext' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMusic_PlayPrevious");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMusic_PlayPrevious");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMusic_PlayPrevious' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMusic_SetVolume");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMusic_SetVolume");
        LOG_TRACE("{} -> 'SteamAPI_ISteamMusic_SetVolume' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingConnectionCustomSignaling_Release");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingConnectionCustomSignaling_Release");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingConnectionCustomSignaling_Release' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingConnectionCustomSignaling_SendSignal");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingConnectionCustomSignaling_SendSignal");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingConnectionCustomSignaling_SendSignal' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingCustomSignalingRecvContext_OnConnectRequest");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingCustomSignalingRecvContext_OnConnectRequest");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingCustomSignalingRecvContext_OnConnectRequest' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingCustomSignalingRecvContext_SendRejectionSignal");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingCustomSignalingRecvContext_SendRejectionSignal");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingCustomSignalingRecvContext_SendRejectionSignal' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingFakeUDPPort_DestroyFakeUDPPort");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingFakeUDPPort_DestroyFakeUDPPort");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingFakeUDPPort_DestroyFakeUDPPort' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingFakeUDPPort_ReceiveMessages");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingFakeUDPPort_ReceiveMessages");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingFakeUDPPort_ReceiveMessages' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingFakeUDPPort_ScheduleCleanup");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingFakeUDPPort_ScheduleCleanup");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingFakeUDPPort_ScheduleCleanup' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingFakeUDPPort_SendMessageToFakeIP");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingFakeUDPPort_SendMessageToFakeIP");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingFakeUDPPort_SendMessageToFakeIP' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingMessages_AcceptSessionWithUser");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingMessages_AcceptSessionWithUser");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingMessages_AcceptSessionWithUser' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingMessages_CloseChannelWithUser");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingMessages_CloseChannelWithUser");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingMessages_CloseChannelWithUser' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingMessages_CloseSessionWithUser");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingMessages_CloseSessionWithUser");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingMessages_CloseSessionWithUser' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingMessages_GetSessionConnectionInfo");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingMessages_GetSessionConnectionInfo");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingMessages_GetSessionConnectionInfo' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingMessages_ReceiveMessagesOnChannel");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingMessages_ReceiveMessagesOnChannel");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingMessages_ReceiveMessagesOnChannel' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingMessages_SendMessageToUser");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingMessages_SendMessageToUser");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingMessages_SendMessageToUser' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_AcceptConnection");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_AcceptConnection");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingSockets_AcceptConnection' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_BeginAsyncRequestFakeIP");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_BeginAsyncRequestFakeIP");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingSockets_BeginAsyncRequestFakeIP' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_CloseConnection");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_CloseConnection");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingSockets_CloseConnection' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_CloseListenSocket");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_CloseListenSocket");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingSockets_CloseListenSocket' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_ConfigureConnectionLanes");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_ConfigureConnectionLanes");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingSockets_ConfigureConnectionLanes' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_ConnectByIPAddress");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_ConnectByIPAddress");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingSockets_ConnectByIPAddress' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_ConnectP2P");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_ConnectP2P");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingSockets_ConnectP2P' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_ConnectP2PCustomSignaling");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_ConnectP2PCustomSignaling");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingSockets_ConnectP2PCustomSignaling' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_ConnectToHostedDedicatedServer");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_ConnectToHostedDedicatedServer");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingSockets_ConnectToHostedDedicatedServer' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_CreateFakeUDPPort");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_CreateFakeUDPPort");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingSockets_CreateFakeUDPPort' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_CreateHostedDedicatedServerListenSocket");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_CreateHostedDedicatedServerListenSocket");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingSockets_CreateHostedDedicatedServerListenSocket' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_CreateListenSocketIP");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_CreateListenSocketIP");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingSockets_CreateListenSocketIP' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_CreateListenSocketP2P");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_CreateListenSocketP2P");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingSockets_CreateListenSocketP2P' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_CreateListenSocketP2PFakeIP");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_CreateListenSocketP2PFakeIP");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingSockets_CreateListenSocketP2PFakeIP' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_CreatePollGroup");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_CreatePollGroup");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingSockets_CreatePollGroup' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_CreateSocketPair");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_CreateSocketPair");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingSockets_CreateSocketPair' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_DestroyPollGroup");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_DestroyPollGroup");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingSockets_DestroyPollGroup' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_FindRelayAuthTicketForServer");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_FindRelayAuthTicketForServer");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingSockets_FindRelayAuthTicketForServer' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_FlushMessagesOnConnection");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_FlushMessagesOnConnection");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingSockets_FlushMessagesOnConnection' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_GetAuthenticationStatus");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_GetAuthenticationStatus");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingSockets_GetAuthenticationStatus' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_GetCertificateRequest");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_GetCertificateRequest");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingSockets_GetCertificateRequest' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_GetConnectionInfo");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_GetConnectionInfo");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingSockets_GetConnectionInfo' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_GetConnectionName");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_GetConnectionName");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingSockets_GetConnectionName' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_GetConnectionRealTimeStatus");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_GetConnectionRealTimeStatus");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingSockets_GetConnectionRealTimeStatus' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_GetConnectionUserData");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_GetConnectionUserData");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingSockets_GetConnectionUserData' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_GetDetailedConnectionStatus");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_GetDetailedConnectionStatus");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingSockets_GetDetailedConnectionStatus' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_GetFakeIP");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_GetFakeIP");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingSockets_GetFakeIP' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_GetGameCoordinatorServerLogin");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_GetGameCoordinatorServerLogin");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingSockets_GetGameCoordinatorServerLogin' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_GetHostedDedicatedServerAddress");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_GetHostedDedicatedServerAddress");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingSockets_GetHostedDedicatedServerAddress' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_GetHostedDedicatedServerPOPID");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_GetHostedDedicatedServerPOPID");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingSockets_GetHostedDedicatedServerPOPID' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_GetHostedDedicatedServerPort");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_GetHostedDedicatedServerPort");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingSockets_GetHostedDedicatedServerPort' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_GetIdentity");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_GetIdentity");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingSockets_GetIdentity' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_GetListenSocketAddress");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_GetListenSocketAddress");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingSockets_GetListenSocketAddress' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_GetQuickConnectionStatus");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_GetQuickConnectionStatus");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingSockets_GetQuickConnectionStatus' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_GetRemoteFakeIPForConnection");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_GetRemoteFakeIPForConnection");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingSockets_GetRemoteFakeIPForConnection' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_InitAuthentication");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_InitAuthentication");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingSockets_InitAuthentication' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_ReceiveMessagesOnConnection");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_ReceiveMessagesOnConnection");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingSockets_ReceiveMessagesOnConnection' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_ReceiveMessagesOnPollGroup");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_ReceiveMessagesOnPollGroup");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingSockets_ReceiveMessagesOnPollGroup' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_ReceivedP2PCustomSignal");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_ReceivedP2PCustomSignal");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingSockets_ReceivedP2PCustomSignal' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_ReceivedRelayAuthTicket");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_ReceivedRelayAuthTicket");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingSockets_ReceivedRelayAuthTicket' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_ResetIdentity");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_ResetIdentity");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingSockets_ResetIdentity' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_RunCallbacks");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_RunCallbacks");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingSockets_RunCallbacks' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_SendMessageToConnection");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_SendMessageToConnection");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingSockets_SendMessageToConnection' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_SendMessages");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_SendMessages");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingSockets_SendMessages' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_SetCertificate");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_SetCertificate");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingSockets_SetCertificate' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_SetConnectionName");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_SetConnectionName");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingSockets_SetConnectionName' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_SetConnectionPollGroup");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_SetConnectionPollGroup");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingSockets_SetConnectionPollGroup' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_SetConnectionUserData");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_SetConnectionUserData");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingSockets_SetConnectionUserData' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingUtils_AllocateMessage");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingUtils_AllocateMessage");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingUtils_AllocateMessage' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingUtils_CheckPingDataUpToDate");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingUtils_CheckPingDataUpToDate");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingUtils_CheckPingDataUpToDate' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingUtils_ConvertPingLocationToString");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingUtils_ConvertPingLocationToString");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingUtils_ConvertPingLocationToString' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingUtils_EstimatePingTimeBetweenTwoLocations");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingUtils_EstimatePingTimeBetweenTwoLocations");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingUtils_EstimatePingTimeBetweenTwoLocations' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingUtils_EstimatePingTimeFromLocalHost");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingUtils_EstimatePingTimeFromLocalHost");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingUtils_EstimatePingTimeFromLocalHost' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingUtils_GetConfigValue");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingUtils_GetConfigValue");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingUtils_GetConfigValue' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingUtils_GetConfigValueInfo");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingUtils_GetConfigValueInfo");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingUtils_GetConfigValueInfo' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingUtils_GetDirectPingToPOP");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingUtils_GetDirectPingToPOP");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingUtils_GetDirectPingToPOP' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingUtils_GetFirstConfigValue");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingUtils_GetFirstConfigValue");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingUtils_GetFirstConfigValue' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingUtils_GetIPv4FakeIPType");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingUtils_GetIPv4FakeIPType");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingUtils_GetIPv4FakeIPType' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingUtils_GetLocalPingLocation");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingUtils_GetLocalPingLocation");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingUtils_GetLocalPingLocation' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingUtils_GetLocalTimestamp");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingUtils_GetLocalTimestamp");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingUtils_GetLocalTimestamp' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingUtils_GetPOPCount");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingUtils_GetPOPCount");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingUtils_GetPOPCount' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingUtils_GetPOPList");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingUtils_GetPOPList");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingUtils_GetPOPList' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingUtils_GetPingToDataCenter");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingUtils_GetPingToDataCenter");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingUtils_GetPingToDataCenter' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingUtils_GetRealIdentityForFakeIP");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingUtils_GetRealIdentityForFakeIP");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingUtils_GetRealIdentityForFakeIP' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingUtils_GetRelayNetworkStatus");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingUtils_GetRelayNetworkStatus");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingUtils_GetRelayNetworkStatus' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingUtils_InitRelayNetworkAccess");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingUtils_InitRelayNetworkAccess");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingUtils_InitRelayNetworkAccess' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingUtils_IsFakeIPv4");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingUtils_IsFakeIPv4");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingUtils_IsFakeIPv4' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingUtils_IterateGenericEditableConfigValues");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingUtils_IterateGenericEditableConfigValues");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingUtils_IterateGenericEditableConfigValues' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingUtils_ParsePingLocationString");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingUtils_ParsePingLocationString");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingUtils_ParsePingLocationString' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingUtils_SetConfigValue");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingUtils_SetConfigValue");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingUtils_SetConfigValue' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingUtils_SetConfigValueStruct");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingUtils_SetConfigValueStruct");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingUtils_SetConfigValueStruct' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingUtils_SetConnectionConfigValueFloat");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingUtils_SetConnectionConfigValueFloat");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingUtils_SetConnectionConfigValueFloat' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingUtils_SetConnectionConfigValueInt32");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingUtils_SetConnectionConfigValueInt32");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingUtils_SetConnectionConfigValueInt32' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingUtils_SetConnectionConfigValueString");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingUtils_SetConnectionConfigValueString");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingUtils_SetConnectionConfigValueString' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingUtils_SetDebugOutputFunction");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingUtils_SetDebugOutputFunction");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingUtils_SetDebugOutputFunction' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingUtils_SetGlobalCallback_FakeIPResult");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingUtils_SetGlobalCallback_FakeIPResult");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingUtils_SetGlobalCallback_FakeIPResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingUtils_SetGlobalCallback_MessagesSessionFailed");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingUtils_SetGlobalCallback_MessagesSessionFailed");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingUtils_SetGlobalCallback_MessagesSessionFailed' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingUtils_SetGlobalCallback_MessagesSessionRequest");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingUtils_SetGlobalCallback_MessagesSessionRequest");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingUtils_SetGlobalCallback_MessagesSessionRequest' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingUtils_SetGlobalCallback_SteamNetAuthenticationStatusChanged");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingUtils_SetGlobalCallback_SteamNetAuthenticationStatusChanged");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingUtils_SetGlobalCallback_SteamNetAuthenticationStatusChanged' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingUtils_SetGlobalCallback_SteamNetConnectionStatusChanged");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingUtils_SetGlobalCallback_SteamNetConnectionStatusChanged");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingUtils_SetGlobalCallback_SteamNetConnectionStatusChanged' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingUtils_SetGlobalCallback_SteamRelayNetworkStatusChanged");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingUtils_SetGlobalCallback_SteamRelayNetworkStatusChanged");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingUtils_SetGlobalCallback_SteamRelayNetworkStatusChanged' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingUtils_SetGlobalConfigValueFloat");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingUtils_SetGlobalConfigValueFloat");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingUtils_SetGlobalConfigValueFloat' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingUtils_SetGlobalConfigValueInt32");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingUtils_SetGlobalConfigValueInt32");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingUtils_SetGlobalConfigValueInt32' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingUtils_SetGlobalConfigValuePtr");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingUtils_SetGlobalConfigValuePtr");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingUtils_SetGlobalConfigValuePtr' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingUtils_SetGlobalConfigValueString");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingUtils_SetGlobalConfigValueString");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingUtils_SetGlobalConfigValueString' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingUtils_SteamNetworkingIPAddr_GetFakeIPType");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingUtils_SteamNetworkingIPAddr_GetFakeIPType");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingUtils_SteamNetworkingIPAddr_GetFakeIPType' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingUtils_SteamNetworkingIPAddr_ParseString");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingUtils_SteamNetworkingIPAddr_ParseString");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingUtils_SteamNetworkingIPAddr_ParseString' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingUtils_SteamNetworkingIPAddr_ToString");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingUtils_SteamNetworkingIPAddr_ToString");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingUtils_SteamNetworkingIPAddr_ToString' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingUtils_SteamNetworkingIdentity_ParseString");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingUtils_SteamNetworkingIdentity_ParseString");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingUtils_SteamNetworkingIdentity_ParseString' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingUtils_SteamNetworkingIdentity_ToString");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingUtils_SteamNetworkingIdentity_ToString");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworkingUtils_SteamNetworkingIdentity_ToString' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworking_AcceptP2PSessionWithUser");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworking_AcceptP2PSessionWithUser");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworking_AcceptP2PSessionWithUser' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworking_AllowP2PPacketRelay");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworking_AllowP2PPacketRelay");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworking_AllowP2PPacketRelay' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworking_CloseP2PChannelWithUser");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworking_CloseP2PChannelWithUser");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworking_CloseP2PChannelWithUser' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworking_CloseP2PSessionWithUser");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworking_CloseP2PSessionWithUser");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworking_CloseP2PSessionWithUser' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworking_CreateConnectionSocket");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworking_CreateConnectionSocket");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworking_CreateConnectionSocket' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworking_CreateListenSocket");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworking_CreateListenSocket");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworking_CreateListenSocket' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworking_CreateP2PConnectionSocket");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworking_CreateP2PConnectionSocket");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworking_CreateP2PConnectionSocket' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworking_DestroyListenSocket");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworking_DestroyListenSocket");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworking_DestroyListenSocket' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworking_DestroySocket");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworking_DestroySocket");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworking_DestroySocket' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworking_GetListenSocketInfo");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworking_GetListenSocketInfo");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworking_GetListenSocketInfo' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworking_GetMaxPacketSize");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworking_GetMaxPacketSize");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworking_GetMaxPacketSize' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworking_GetP2PSessionState");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworking_GetP2PSessionState");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworking_GetP2PSessionState' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworking_GetSocketConnectionType");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworking_GetSocketConnectionType");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworking_GetSocketConnectionType' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworking_GetSocketInfo");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworking_GetSocketInfo");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworking_GetSocketInfo' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworking_IsDataAvailable");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworking_IsDataAvailable");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworking_IsDataAvailable' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworking_IsDataAvailableOnSocket");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworking_IsDataAvailableOnSocket");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworking_IsDataAvailableOnSocket' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworking_IsP2PPacketAvailable");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworking_IsP2PPacketAvailable");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworking_IsP2PPacketAvailable' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworking_ReadP2PPacket");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworking_ReadP2PPacket");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworking_ReadP2PPacket' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworking_RetrieveData");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworking_RetrieveData");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworking_RetrieveData' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworking_RetrieveDataFromSocket");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworking_RetrieveDataFromSocket");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworking_RetrieveDataFromSocket' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworking_SendDataOnSocket");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworking_SendDataOnSocket");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworking_SendDataOnSocket' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworking_SendP2PPacket");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworking_SendP2PPacket");
        LOG_TRACE("{} -> 'SteamAPI_ISteamNetworking_SendP2PPacket' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamParentalSettings_BIsAppBlocked");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamParentalSettings_BIsAppBlocked");
        LOG_TRACE("{} -> 'SteamAPI_ISteamParentalSettings_BIsAppBlocked' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamParentalSettings_BIsAppInBlockList");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamParentalSettings_BIsAppInBlockList");
        LOG_TRACE("{} -> 'SteamAPI_ISteamParentalSettings_BIsAppInBlockList' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamParentalSettings_BIsFeatureBlocked");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamParentalSettings_BIsFeatureBlocked");
        LOG_TRACE("{} -> 'SteamAPI_ISteamParentalSettings_BIsFeatureBlocked' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamParentalSettings_BIsFeatureInBlockList");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamParentalSettings_BIsFeatureInBlockList");
        LOG_TRACE("{} -> 'SteamAPI_ISteamParentalSettings_BIsFeatureInBlockList' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamParentalSettings_BIsParentalLockEnabled");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamParentalSettings_BIsParentalLockEnabled");
        LOG_TRACE("{} -> 'SteamAPI_ISteamParentalSettings_BIsParentalLockEnabled' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamParentalSettings_BIsParentalLockLocked");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamParentalSettings_BIsParentalLockLocked");
        LOG_TRACE("{} -> 'SteamAPI_ISteamParentalSettings_BIsParentalLockLocked' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamParties_CancelReservation");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamParties_CancelReservation");
        LOG_TRACE("{} -> 'SteamAPI_ISteamParties_CancelReservation' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamParties_ChangeNumOpenSlots");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamParties_ChangeNumOpenSlots");
        LOG_TRACE("{} -> 'SteamAPI_ISteamParties_ChangeNumOpenSlots' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamParties_CreateBeacon");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamParties_CreateBeacon");
        LOG_TRACE("{} -> 'SteamAPI_ISteamParties_CreateBeacon' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamParties_DestroyBeacon");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamParties_DestroyBeacon");
        LOG_TRACE("{} -> 'SteamAPI_ISteamParties_DestroyBeacon' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamParties_GetAvailableBeaconLocations");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamParties_GetAvailableBeaconLocations");
        LOG_TRACE("{} -> 'SteamAPI_ISteamParties_GetAvailableBeaconLocations' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamParties_GetBeaconByIndex");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamParties_GetBeaconByIndex");
        LOG_TRACE("{} -> 'SteamAPI_ISteamParties_GetBeaconByIndex' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamParties_GetBeaconDetails");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamParties_GetBeaconDetails");
        LOG_TRACE("{} -> 'SteamAPI_ISteamParties_GetBeaconDetails' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamParties_GetBeaconLocationData");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamParties_GetBeaconLocationData");
        LOG_TRACE("{} -> 'SteamAPI_ISteamParties_GetBeaconLocationData' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamParties_GetNumActiveBeacons");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamParties_GetNumActiveBeacons");
        LOG_TRACE("{} -> 'SteamAPI_ISteamParties_GetNumActiveBeacons' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamParties_GetNumAvailableBeaconLocations");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamParties_GetNumAvailableBeaconLocations");
        LOG_TRACE("{} -> 'SteamAPI_ISteamParties_GetNumAvailableBeaconLocations' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamParties_JoinParty");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamParties_JoinParty");
        LOG_TRACE("{} -> 'SteamAPI_ISteamParties_JoinParty' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamParties_OnReservationCompleted");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamParties_OnReservationCompleted");
        LOG_TRACE("{} -> 'SteamAPI_ISteamParties_OnReservationCompleted' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemotePlay_BEnableRemotePlayTogetherDirectInput");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemotePlay_BEnableRemotePlayTogetherDirectInput");
        LOG_TRACE("{} -> 'SteamAPI_ISteamRemotePlay_BEnableRemotePlayTogetherDirectInput' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemotePlay_BGetSessionClientResolution");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemotePlay_BGetSessionClientResolution");
        LOG_TRACE("{} -> 'SteamAPI_ISteamRemotePlay_BGetSessionClientResolution' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemotePlay_BSendRemotePlayTogetherInvite");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemotePlay_BSendRemotePlayTogetherInvite");
        LOG_TRACE("{} -> 'SteamAPI_ISteamRemotePlay_BSendRemotePlayTogetherInvite' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemotePlay_BStartRemotePlayTogether");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemotePlay_BStartRemotePlayTogether");
        LOG_TRACE("{} -> 'SteamAPI_ISteamRemotePlay_BStartRemotePlayTogether' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemotePlay_CreateMouseCursor");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemotePlay_CreateMouseCursor");
        LOG_TRACE("{} -> 'SteamAPI_ISteamRemotePlay_CreateMouseCursor' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemotePlay_DisableRemotePlayTogetherDirectInput");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemotePlay_DisableRemotePlayTogetherDirectInput");
        LOG_TRACE("{} -> 'SteamAPI_ISteamRemotePlay_DisableRemotePlayTogetherDirectInput' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemotePlay_GetInput");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemotePlay_GetInput");
        LOG_TRACE("{} -> 'SteamAPI_ISteamRemotePlay_GetInput' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemotePlay_GetSessionClientFormFactor");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemotePlay_GetSessionClientFormFactor");
        LOG_TRACE("{} -> 'SteamAPI_ISteamRemotePlay_GetSessionClientFormFactor' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemotePlay_GetSessionClientName");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemotePlay_GetSessionClientName");
        LOG_TRACE("{} -> 'SteamAPI_ISteamRemotePlay_GetSessionClientName' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemotePlay_GetSessionCount");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemotePlay_GetSessionCount");
        LOG_TRACE("{} -> 'SteamAPI_ISteamRemotePlay_GetSessionCount' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemotePlay_GetSessionID");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemotePlay_GetSessionID");
        LOG_TRACE("{} -> 'SteamAPI_ISteamRemotePlay_GetSessionID' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemotePlay_GetSessionSteamID");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemotePlay_GetSessionSteamID");
        LOG_TRACE("{} -> 'SteamAPI_ISteamRemotePlay_GetSessionSteamID' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemotePlay_SetMouseCursor");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemotePlay_SetMouseCursor");
        LOG_TRACE("{} -> 'SteamAPI_ISteamRemotePlay_SetMouseCursor' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemotePlay_SetMousePosition");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemotePlay_SetMousePosition");
        LOG_TRACE("{} -> 'SteamAPI_ISteamRemotePlay_SetMousePosition' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemotePlay_SetMouseVisibility");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemotePlay_SetMouseVisibility");
        LOG_TRACE("{} -> 'SteamAPI_ISteamRemotePlay_SetMouseVisibility' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemotePlay_ShowRemotePlayTogetherUI");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemotePlay_ShowRemotePlayTogetherUI");
        LOG_TRACE("{} -> 'SteamAPI_ISteamRemotePlay_ShowRemotePlayTogetherUI' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_BeginFileWriteBatch");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_BeginFileWriteBatch");
        LOG_TRACE("{} -> 'SteamAPI_ISteamRemoteStorage_BeginFileWriteBatch' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_CommitPublishedFileUpdate");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_CommitPublishedFileUpdate");
        LOG_TRACE("{} -> 'SteamAPI_ISteamRemoteStorage_CommitPublishedFileUpdate' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_CreatePublishedFileUpdateRequest");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_CreatePublishedFileUpdateRequest");
        LOG_TRACE("{} -> 'SteamAPI_ISteamRemoteStorage_CreatePublishedFileUpdateRequest' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_DeletePublishedFile");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_DeletePublishedFile");
        LOG_TRACE("{} -> 'SteamAPI_ISteamRemoteStorage_DeletePublishedFile' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_EndFileWriteBatch");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_EndFileWriteBatch");
        LOG_TRACE("{} -> 'SteamAPI_ISteamRemoteStorage_EndFileWriteBatch' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_EnumeratePublishedFilesByUserAction");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_EnumeratePublishedFilesByUserAction");
        LOG_TRACE("{} -> 'SteamAPI_ISteamRemoteStorage_EnumeratePublishedFilesByUserAction' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_EnumeratePublishedWorkshopFiles");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_EnumeratePublishedWorkshopFiles");
        LOG_TRACE("{} -> 'SteamAPI_ISteamRemoteStorage_EnumeratePublishedWorkshopFiles' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_EnumerateUserPublishedFiles");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_EnumerateUserPublishedFiles");
        LOG_TRACE("{} -> 'SteamAPI_ISteamRemoteStorage_EnumerateUserPublishedFiles' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_EnumerateUserSharedWorkshopFiles");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_EnumerateUserSharedWorkshopFiles");
        LOG_TRACE("{} -> 'SteamAPI_ISteamRemoteStorage_EnumerateUserSharedWorkshopFiles' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_EnumerateUserSubscribedFiles");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_EnumerateUserSubscribedFiles");
        LOG_TRACE("{} -> 'SteamAPI_ISteamRemoteStorage_EnumerateUserSubscribedFiles' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_FileDelete");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_FileDelete");
        LOG_TRACE("{} -> 'SteamAPI_ISteamRemoteStorage_FileDelete' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_FileExists");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_FileExists");
        LOG_TRACE("{} -> 'SteamAPI_ISteamRemoteStorage_FileExists' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_FileForget");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_FileForget");
        LOG_TRACE("{} -> 'SteamAPI_ISteamRemoteStorage_FileForget' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_FilePersisted");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_FilePersisted");
        LOG_TRACE("{} -> 'SteamAPI_ISteamRemoteStorage_FilePersisted' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_FileRead");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_FileRead");
        LOG_TRACE("{} -> 'SteamAPI_ISteamRemoteStorage_FileRead' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_FileReadAsync");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_FileReadAsync");
        LOG_TRACE("{} -> 'SteamAPI_ISteamRemoteStorage_FileReadAsync' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_FileReadAsyncComplete");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_FileReadAsyncComplete");
        LOG_TRACE("{} -> 'SteamAPI_ISteamRemoteStorage_FileReadAsyncComplete' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_FileShare");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_FileShare");
        LOG_TRACE("{} -> 'SteamAPI_ISteamRemoteStorage_FileShare' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_FileWrite");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_FileWrite");
        LOG_TRACE("{} -> 'SteamAPI_ISteamRemoteStorage_FileWrite' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_FileWriteAsync");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_FileWriteAsync");
        LOG_TRACE("{} -> 'SteamAPI_ISteamRemoteStorage_FileWriteAsync' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_FileWriteStreamCancel");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_FileWriteStreamCancel");
        LOG_TRACE("{} -> 'SteamAPI_ISteamRemoteStorage_FileWriteStreamCancel' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_FileWriteStreamClose");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_FileWriteStreamClose");
        LOG_TRACE("{} -> 'SteamAPI_ISteamRemoteStorage_FileWriteStreamClose' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_FileWriteStreamOpen");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_FileWriteStreamOpen");
        LOG_TRACE("{} -> 'SteamAPI_ISteamRemoteStorage_FileWriteStreamOpen' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_FileWriteStreamWriteChunk");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_FileWriteStreamWriteChunk");
        LOG_TRACE("{} -> 'SteamAPI_ISteamRemoteStorage_FileWriteStreamWriteChunk' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_GetCachedUGCCount");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_GetCachedUGCCount");
        LOG_TRACE("{} -> 'SteamAPI_ISteamRemoteStorage_GetCachedUGCCount' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_GetCachedUGCHandle");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_GetCachedUGCHandle");
        LOG_TRACE("{} -> 'SteamAPI_ISteamRemoteStorage_GetCachedUGCHandle' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_GetFileCount");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_GetFileCount");
        LOG_TRACE("{} -> 'SteamAPI_ISteamRemoteStorage_GetFileCount' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_GetFileNameAndSize");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_GetFileNameAndSize");
        LOG_TRACE("{} -> 'SteamAPI_ISteamRemoteStorage_GetFileNameAndSize' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_GetFileSize");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_GetFileSize");
        LOG_TRACE("{} -> 'SteamAPI_ISteamRemoteStorage_GetFileSize' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_GetFileTimestamp");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_GetFileTimestamp");
        LOG_TRACE("{} -> 'SteamAPI_ISteamRemoteStorage_GetFileTimestamp' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_GetLocalFileChange");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_GetLocalFileChange");
        LOG_TRACE("{} -> 'SteamAPI_ISteamRemoteStorage_GetLocalFileChange' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_GetLocalFileChangeCount");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_GetLocalFileChangeCount");
        LOG_TRACE("{} -> 'SteamAPI_ISteamRemoteStorage_GetLocalFileChangeCount' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_GetPublishedFileDetails");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_GetPublishedFileDetails");
        LOG_TRACE("{} -> 'SteamAPI_ISteamRemoteStorage_GetPublishedFileDetails' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_GetPublishedItemVoteDetails");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_GetPublishedItemVoteDetails");
        LOG_TRACE("{} -> 'SteamAPI_ISteamRemoteStorage_GetPublishedItemVoteDetails' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_GetQuota");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_GetQuota");
        LOG_TRACE("{} -> 'SteamAPI_ISteamRemoteStorage_GetQuota' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_GetSyncPlatforms");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_GetSyncPlatforms");
        LOG_TRACE("{} -> 'SteamAPI_ISteamRemoteStorage_GetSyncPlatforms' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_GetUGCDetails");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_GetUGCDetails");
        LOG_TRACE("{} -> 'SteamAPI_ISteamRemoteStorage_GetUGCDetails' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_GetUGCDownloadProgress");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_GetUGCDownloadProgress");
        LOG_TRACE("{} -> 'SteamAPI_ISteamRemoteStorage_GetUGCDownloadProgress' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_GetUserPublishedItemVoteDetails");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_GetUserPublishedItemVoteDetails");
        LOG_TRACE("{} -> 'SteamAPI_ISteamRemoteStorage_GetUserPublishedItemVoteDetails' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_IsCloudEnabledForAccount");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_IsCloudEnabledForAccount");
        LOG_TRACE("{} -> 'SteamAPI_ISteamRemoteStorage_IsCloudEnabledForAccount' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_IsCloudEnabledForApp");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_IsCloudEnabledForApp");
        LOG_TRACE("{} -> 'SteamAPI_ISteamRemoteStorage_IsCloudEnabledForApp' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_PublishVideo");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_PublishVideo");
        LOG_TRACE("{} -> 'SteamAPI_ISteamRemoteStorage_PublishVideo' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_PublishWorkshopFile");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_PublishWorkshopFile");
        LOG_TRACE("{} -> 'SteamAPI_ISteamRemoteStorage_PublishWorkshopFile' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_SetCloudEnabledForApp");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_SetCloudEnabledForApp");
        LOG_TRACE("{} -> 'SteamAPI_ISteamRemoteStorage_SetCloudEnabledForApp' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_SetSyncPlatforms");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_SetSyncPlatforms");
        LOG_TRACE("{} -> 'SteamAPI_ISteamRemoteStorage_SetSyncPlatforms' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_SetUserPublishedFileAction");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_SetUserPublishedFileAction");
        LOG_TRACE("{} -> 'SteamAPI_ISteamRemoteStorage_SetUserPublishedFileAction' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_SubscribePublishedFile");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_SubscribePublishedFile");
        LOG_TRACE("{} -> 'SteamAPI_ISteamRemoteStorage_SubscribePublishedFile' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_UGCDownload");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_UGCDownload");
        LOG_TRACE("{} -> 'SteamAPI_ISteamRemoteStorage_UGCDownload' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_UGCDownloadToLocation");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_UGCDownloadToLocation");
        LOG_TRACE("{} -> 'SteamAPI_ISteamRemoteStorage_UGCDownloadToLocation' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_UGCRead");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_UGCRead");
        LOG_TRACE("{} -> 'SteamAPI_ISteamRemoteStorage_UGCRead' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_UnsubscribePublishedFile");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_UnsubscribePublishedFile");
        LOG_TRACE("{} -> 'SteamAPI_ISteamRemoteStorage_UnsubscribePublishedFile' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_UpdatePublishedFileDescription");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_UpdatePublishedFileDescription");
        LOG_TRACE("{} -> 'SteamAPI_ISteamRemoteStorage_UpdatePublishedFileDescription' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_UpdatePublishedFileFile");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_UpdatePublishedFileFile");
        LOG_TRACE("{} -> 'SteamAPI_ISteamRemoteStorage_UpdatePublishedFileFile' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_UpdatePublishedFilePreviewFile");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_UpdatePublishedFilePreviewFile");
        LOG_TRACE("{} -> 'SteamAPI_ISteamRemoteStorage_UpdatePublishedFilePreviewFile' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_UpdatePublishedFileSetChangeDescription");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_UpdatePublishedFileSetChangeDescription");
        LOG_TRACE("{} -> 'SteamAPI_ISteamRemoteStorage_UpdatePublishedFileSetChangeDescription' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_UpdatePublishedFileTags");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_UpdatePublishedFileTags");
        LOG_TRACE("{} -> 'SteamAPI_ISteamRemoteStorage_UpdatePublishedFileTags' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_UpdatePublishedFileTitle");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_UpdatePublishedFileTitle");
        LOG_TRACE("{} -> 'SteamAPI_ISteamRemoteStorage_UpdatePublishedFileTitle' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_UpdatePublishedFileVisibility");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_UpdatePublishedFileVisibility");
        LOG_TRACE("{} -> 'SteamAPI_ISteamRemoteStorage_UpdatePublishedFileVisibility' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_UpdateUserPublishedItemVote");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_UpdateUserPublishedItemVote");
        LOG_TRACE("{} -> 'SteamAPI_ISteamRemoteStorage_UpdateUserPublishedItemVote' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamScreenshots_AddScreenshotToLibrary");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamScreenshots_AddScreenshotToLibrary");
        LOG_TRACE("{} -> 'SteamAPI_ISteamScreenshots_AddScreenshotToLibrary' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamScreenshots_AddVRScreenshotToLibrary");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamScreenshots_AddVRScreenshotToLibrary");
        LOG_TRACE("{} -> 'SteamAPI_ISteamScreenshots_AddVRScreenshotToLibrary' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamScreenshots_HookScreenshots");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamScreenshots_HookScreenshots");
        LOG_TRACE("{} -> 'SteamAPI_ISteamScreenshots_HookScreenshots' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamScreenshots_IsScreenshotsHooked");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamScreenshots_IsScreenshotsHooked");
        LOG_TRACE("{} -> 'SteamAPI_ISteamScreenshots_IsScreenshotsHooked' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamScreenshots_SetLocation");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamScreenshots_SetLocation");
        LOG_TRACE("{} -> 'SteamAPI_ISteamScreenshots_SetLocation' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamScreenshots_TagPublishedFile");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamScreenshots_TagPublishedFile");
        LOG_TRACE("{} -> 'SteamAPI_ISteamScreenshots_TagPublishedFile' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamScreenshots_TagUser");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamScreenshots_TagUser");
        LOG_TRACE("{} -> 'SteamAPI_ISteamScreenshots_TagUser' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamScreenshots_TriggerScreenshot");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamScreenshots_TriggerScreenshot");
        LOG_TRACE("{} -> 'SteamAPI_ISteamScreenshots_TriggerScreenshot' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamScreenshots_WriteScreenshot");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamScreenshots_WriteScreenshot");
        LOG_TRACE("{} -> 'SteamAPI_ISteamScreenshots_WriteScreenshot' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamTV_AddBroadcastGameData");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamTV_AddBroadcastGameData");
        LOG_TRACE("{} -> 'SteamAPI_ISteamTV_AddBroadcastGameData' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamTV_AddRegion");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamTV_AddRegion");
        LOG_TRACE("{} -> 'SteamAPI_ISteamTV_AddRegion' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamTV_AddTimelineMarker");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamTV_AddTimelineMarker");
        LOG_TRACE("{} -> 'SteamAPI_ISteamTV_AddTimelineMarker' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamTV_IsBroadcasting");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamTV_IsBroadcasting");
        LOG_TRACE("{} -> 'SteamAPI_ISteamTV_IsBroadcasting' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamTV_RemoveBroadcastGameData");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamTV_RemoveBroadcastGameData");
        LOG_TRACE("{} -> 'SteamAPI_ISteamTV_RemoveBroadcastGameData' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamTV_RemoveRegion");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamTV_RemoveRegion");
        LOG_TRACE("{} -> 'SteamAPI_ISteamTV_RemoveRegion' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamTV_RemoveTimelineMarker");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamTV_RemoveTimelineMarker");
        LOG_TRACE("{} -> 'SteamAPI_ISteamTV_RemoveTimelineMarker' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamTimeline_AddGamePhaseTag");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamTimeline_AddGamePhaseTag");
        LOG_TRACE("{} -> 'SteamAPI_ISteamTimeline_AddGamePhaseTag' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamTimeline_AddInstantaneousTimelineEvent");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamTimeline_AddInstantaneousTimelineEvent");
        LOG_TRACE("{} -> 'SteamAPI_ISteamTimeline_AddInstantaneousTimelineEvent' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamTimeline_AddRangeTimelineEvent");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamTimeline_AddRangeTimelineEvent");
        LOG_TRACE("{} -> 'SteamAPI_ISteamTimeline_AddRangeTimelineEvent' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamTimeline_AddTimelineEvent");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamTimeline_AddTimelineEvent");
        LOG_TRACE("{} -> 'SteamAPI_ISteamTimeline_AddTimelineEvent' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamTimeline_ClearTimelineStateDescription");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamTimeline_ClearTimelineStateDescription");
        LOG_TRACE("{} -> 'SteamAPI_ISteamTimeline_ClearTimelineStateDescription' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamTimeline_ClearTimelineTooltip");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamTimeline_ClearTimelineTooltip");
        LOG_TRACE("{} -> 'SteamAPI_ISteamTimeline_ClearTimelineTooltip' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamTimeline_DoesEventRecordingExist");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamTimeline_DoesEventRecordingExist");
        LOG_TRACE("{} -> 'SteamAPI_ISteamTimeline_DoesEventRecordingExist' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamTimeline_DoesGamePhaseRecordingExist");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamTimeline_DoesGamePhaseRecordingExist");
        LOG_TRACE("{} -> 'SteamAPI_ISteamTimeline_DoesGamePhaseRecordingExist' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamTimeline_EndGamePhase");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamTimeline_EndGamePhase");
        LOG_TRACE("{} -> 'SteamAPI_ISteamTimeline_EndGamePhase' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamTimeline_EndRangeTimelineEvent");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamTimeline_EndRangeTimelineEvent");
        LOG_TRACE("{} -> 'SteamAPI_ISteamTimeline_EndRangeTimelineEvent' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamTimeline_OpenOverlayToGamePhase");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamTimeline_OpenOverlayToGamePhase");
        LOG_TRACE("{} -> 'SteamAPI_ISteamTimeline_OpenOverlayToGamePhase' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamTimeline_OpenOverlayToTimelineEvent");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamTimeline_OpenOverlayToTimelineEvent");
        LOG_TRACE("{} -> 'SteamAPI_ISteamTimeline_OpenOverlayToTimelineEvent' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamTimeline_RemoveTimelineEvent");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamTimeline_RemoveTimelineEvent");
        LOG_TRACE("{} -> 'SteamAPI_ISteamTimeline_RemoveTimelineEvent' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamTimeline_SetGamePhaseAttribute");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamTimeline_SetGamePhaseAttribute");
        LOG_TRACE("{} -> 'SteamAPI_ISteamTimeline_SetGamePhaseAttribute' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamTimeline_SetGamePhaseID");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamTimeline_SetGamePhaseID");
        LOG_TRACE("{} -> 'SteamAPI_ISteamTimeline_SetGamePhaseID' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamTimeline_SetTimelineGameMode");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamTimeline_SetTimelineGameMode");
        LOG_TRACE("{} -> 'SteamAPI_ISteamTimeline_SetTimelineGameMode' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamTimeline_SetTimelineStateDescription");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamTimeline_SetTimelineStateDescription");
        LOG_TRACE("{} -> 'SteamAPI_ISteamTimeline_SetTimelineStateDescription' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamTimeline_SetTimelineTooltip");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamTimeline_SetTimelineTooltip");
        LOG_TRACE("{} -> 'SteamAPI_ISteamTimeline_SetTimelineTooltip' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamTimeline_StartGamePhase");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamTimeline_StartGamePhase");
        LOG_TRACE("{} -> 'SteamAPI_ISteamTimeline_StartGamePhase' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamTimeline_StartRangeTimelineEvent");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamTimeline_StartRangeTimelineEvent");
        LOG_TRACE("{} -> 'SteamAPI_ISteamTimeline_StartRangeTimelineEvent' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamTimeline_UpdateRangeTimelineEvent");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamTimeline_UpdateRangeTimelineEvent");
        LOG_TRACE("{} -> 'SteamAPI_ISteamTimeline_UpdateRangeTimelineEvent' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_AddAppDependency");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_AddAppDependency");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_AddAppDependency' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_AddContentDescriptor");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_AddContentDescriptor");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_AddContentDescriptor' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_AddDependency");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_AddDependency");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_AddDependency' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_AddExcludedTag");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_AddExcludedTag");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_AddExcludedTag' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_AddItemKeyValueTag");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_AddItemKeyValueTag");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_AddItemKeyValueTag' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_AddItemPreviewFile");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_AddItemPreviewFile");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_AddItemPreviewFile' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_AddItemPreviewVideo");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_AddItemPreviewVideo");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_AddItemPreviewVideo' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_AddItemToFavorites");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_AddItemToFavorites");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_AddItemToFavorites' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_AddRequiredKeyValueTag");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_AddRequiredKeyValueTag");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_AddRequiredKeyValueTag' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_AddRequiredTag");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_AddRequiredTag");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_AddRequiredTag' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_AddRequiredTagGroup");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_AddRequiredTagGroup");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_AddRequiredTagGroup' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_BInitWorkshopForGameServer");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_BInitWorkshopForGameServer");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_BInitWorkshopForGameServer' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_CreateItem");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_CreateItem");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_CreateItem' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_CreateQueryAllUGCRequest");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_CreateQueryAllUGCRequest");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_CreateQueryAllUGCRequest' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_CreateQueryAllUGCRequest0");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_CreateQueryAllUGCRequest0");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_CreateQueryAllUGCRequest0' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_CreateQueryAllUGCRequestCursor");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_CreateQueryAllUGCRequestCursor");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_CreateQueryAllUGCRequestCursor' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_CreateQueryAllUGCRequestPage");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_CreateQueryAllUGCRequestPage");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_CreateQueryAllUGCRequestPage' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_CreateQueryUGCDetailsRequest");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_CreateQueryUGCDetailsRequest");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_CreateQueryUGCDetailsRequest' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_CreateQueryUserUGCRequest");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_CreateQueryUserUGCRequest");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_CreateQueryUserUGCRequest' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_DeleteItem");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_DeleteItem");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_DeleteItem' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_DownloadItem");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_DownloadItem");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_DownloadItem' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_GetAppDependencies");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_GetAppDependencies");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_GetAppDependencies' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_GetItemDownloadInfo");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_GetItemDownloadInfo");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_GetItemDownloadInfo' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_GetItemInstallInfo");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_GetItemInstallInfo");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_GetItemInstallInfo' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_GetItemState");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_GetItemState");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_GetItemState' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_GetItemUpdateProgress");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_GetItemUpdateProgress");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_GetItemUpdateProgress' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_GetNumSubscribedItems");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_GetNumSubscribedItems");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_GetNumSubscribedItems' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_GetNumSupportedGameVersions");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_GetNumSupportedGameVersions");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_GetNumSupportedGameVersions' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_GetQueryFirstUGCKeyValueTag");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_GetQueryFirstUGCKeyValueTag");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_GetQueryFirstUGCKeyValueTag' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_GetQueryUGCAdditionalPreview");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_GetQueryUGCAdditionalPreview");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_GetQueryUGCAdditionalPreview' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_GetQueryUGCChildren");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_GetQueryUGCChildren");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_GetQueryUGCChildren' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_GetQueryUGCContentDescriptors");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_GetQueryUGCContentDescriptors");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_GetQueryUGCContentDescriptors' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_GetQueryUGCKeyValueTag");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_GetQueryUGCKeyValueTag");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_GetQueryUGCKeyValueTag' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_GetQueryUGCKeyValueTag0");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_GetQueryUGCKeyValueTag0");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_GetQueryUGCKeyValueTag0' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_GetQueryUGCMetadata");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_GetQueryUGCMetadata");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_GetQueryUGCMetadata' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_GetQueryUGCNumAdditionalPreviews");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_GetQueryUGCNumAdditionalPreviews");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_GetQueryUGCNumAdditionalPreviews' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_GetQueryUGCNumKeyValueTags");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_GetQueryUGCNumKeyValueTags");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_GetQueryUGCNumKeyValueTags' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_GetQueryUGCNumTags");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_GetQueryUGCNumTags");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_GetQueryUGCNumTags' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_GetQueryUGCPreviewURL");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_GetQueryUGCPreviewURL");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_GetQueryUGCPreviewURL' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_GetQueryUGCResult");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_GetQueryUGCResult");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_GetQueryUGCResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_GetQueryUGCStatistic");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_GetQueryUGCStatistic");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_GetQueryUGCStatistic' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_GetQueryUGCTag");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_GetQueryUGCTag");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_GetQueryUGCTag' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_GetQueryUGCTagDisplayName");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_GetQueryUGCTagDisplayName");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_GetQueryUGCTagDisplayName' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_GetSubscribedItems");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_GetSubscribedItems");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_GetSubscribedItems' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_GetSupportedGameVersionData");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_GetSupportedGameVersionData");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_GetSupportedGameVersionData' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_GetUserContentDescriptorPreferences");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_GetUserContentDescriptorPreferences");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_GetUserContentDescriptorPreferences' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_GetUserItemVote");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_GetUserItemVote");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_GetUserItemVote' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_GetWorkshopEULAStatus");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_GetWorkshopEULAStatus");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_GetWorkshopEULAStatus' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_ReleaseQueryUGCRequest");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_ReleaseQueryUGCRequest");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_ReleaseQueryUGCRequest' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_RemoveAllItemKeyValueTags");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_RemoveAllItemKeyValueTags");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_RemoveAllItemKeyValueTags' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_RemoveAppDependency");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_RemoveAppDependency");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_RemoveAppDependency' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_RemoveContentDescriptor");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_RemoveContentDescriptor");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_RemoveContentDescriptor' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_RemoveDependency");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_RemoveDependency");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_RemoveDependency' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_RemoveItemFromFavorites");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_RemoveItemFromFavorites");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_RemoveItemFromFavorites' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_RemoveItemKeyValueTags");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_RemoveItemKeyValueTags");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_RemoveItemKeyValueTags' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_RemoveItemPreview");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_RemoveItemPreview");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_RemoveItemPreview' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_RequestUGCDetails");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_RequestUGCDetails");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_RequestUGCDetails' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_SendQueryUGCRequest");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_SendQueryUGCRequest");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_SendQueryUGCRequest' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_SetAdminQuery");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_SetAdminQuery");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_SetAdminQuery' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_SetAllowCachedResponse");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_SetAllowCachedResponse");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_SetAllowCachedResponse' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_SetAllowLegacyUpload");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_SetAllowLegacyUpload");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_SetAllowLegacyUpload' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_SetCloudFileNameFilter");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_SetCloudFileNameFilter");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_SetCloudFileNameFilter' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_SetItemContent");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_SetItemContent");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_SetItemContent' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_SetItemDescription");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_SetItemDescription");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_SetItemDescription' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_SetItemMetadata");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_SetItemMetadata");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_SetItemMetadata' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_SetItemPreview");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_SetItemPreview");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_SetItemPreview' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_SetItemTags");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_SetItemTags");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_SetItemTags' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_SetItemTitle");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_SetItemTitle");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_SetItemTitle' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_SetItemUpdateLanguage");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_SetItemUpdateLanguage");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_SetItemUpdateLanguage' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_SetItemVisibility");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_SetItemVisibility");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_SetItemVisibility' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_SetItemsDisabledLocally");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_SetItemsDisabledLocally");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_SetItemsDisabledLocally' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_SetLanguage");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_SetLanguage");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_SetLanguage' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_SetMatchAnyTag");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_SetMatchAnyTag");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_SetMatchAnyTag' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_SetRankedByTrendDays");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_SetRankedByTrendDays");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_SetRankedByTrendDays' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_SetRequiredGameVersions");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_SetRequiredGameVersions");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_SetRequiredGameVersions' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_SetReturnAdditionalPreviews");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_SetReturnAdditionalPreviews");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_SetReturnAdditionalPreviews' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_SetReturnChildren");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_SetReturnChildren");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_SetReturnChildren' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_SetReturnKeyValueTags");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_SetReturnKeyValueTags");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_SetReturnKeyValueTags' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_SetReturnLongDescription");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_SetReturnLongDescription");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_SetReturnLongDescription' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_SetReturnMetadata");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_SetReturnMetadata");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_SetReturnMetadata' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_SetReturnOnlyIDs");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_SetReturnOnlyIDs");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_SetReturnOnlyIDs' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_SetReturnPlaytimeStats");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_SetReturnPlaytimeStats");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_SetReturnPlaytimeStats' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_SetReturnTotalOnly");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_SetReturnTotalOnly");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_SetReturnTotalOnly' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_SetSearchText");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_SetSearchText");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_SetSearchText' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_SetSubscriptionsLoadOrder");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_SetSubscriptionsLoadOrder");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_SetSubscriptionsLoadOrder' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_SetTimeCreatedDateRange");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_SetTimeCreatedDateRange");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_SetTimeCreatedDateRange' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_SetTimeUpdatedDateRange");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_SetTimeUpdatedDateRange");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_SetTimeUpdatedDateRange' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_SetUserItemVote");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_SetUserItemVote");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_SetUserItemVote' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_ShowWorkshopEULA");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_ShowWorkshopEULA");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_ShowWorkshopEULA' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_StartItemUpdate");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_StartItemUpdate");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_StartItemUpdate' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_StartPlaytimeTracking");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_StartPlaytimeTracking");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_StartPlaytimeTracking' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_StopPlaytimeTracking");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_StopPlaytimeTracking");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_StopPlaytimeTracking' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_StopPlaytimeTrackingForAllItems");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_StopPlaytimeTrackingForAllItems");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_StopPlaytimeTrackingForAllItems' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_SubmitItemUpdate");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_SubmitItemUpdate");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_SubmitItemUpdate' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_SubscribeItem");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_SubscribeItem");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_SubscribeItem' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_SuspendDownloads");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_SuspendDownloads");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_SuspendDownloads' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_UnsubscribeItem");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_UnsubscribeItem");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_UnsubscribeItem' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_UpdateItemPreviewFile");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_UpdateItemPreviewFile");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_UpdateItemPreviewFile' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_UpdateItemPreviewVideo");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_UpdateItemPreviewVideo");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUGC_UpdateItemPreviewVideo' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUnifiedMessages_GetMethodResponseData");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUnifiedMessages_GetMethodResponseData");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUnifiedMessages_GetMethodResponseData' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUnifiedMessages_GetMethodResponseInfo");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUnifiedMessages_GetMethodResponseInfo");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUnifiedMessages_GetMethodResponseInfo' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUnifiedMessages_ReleaseMethod");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUnifiedMessages_ReleaseMethod");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUnifiedMessages_ReleaseMethod' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUnifiedMessages_SendMethod");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUnifiedMessages_SendMethod");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUnifiedMessages_SendMethod' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUnifiedMessages_SendNotification");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUnifiedMessages_SendNotification");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUnifiedMessages_SendNotification' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_AttachLeaderboardUGC");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_AttachLeaderboardUGC");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUserStats_AttachLeaderboardUGC' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_ClearAchievement");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_ClearAchievement");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUserStats_ClearAchievement' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_DownloadLeaderboardEntries");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_DownloadLeaderboardEntries");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUserStats_DownloadLeaderboardEntries' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_DownloadLeaderboardEntriesForUsers");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_DownloadLeaderboardEntriesForUsers");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUserStats_DownloadLeaderboardEntriesForUsers' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_FindLeaderboard");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_FindLeaderboard");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUserStats_FindLeaderboard' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_FindOrCreateLeaderboard");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_FindOrCreateLeaderboard");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUserStats_FindOrCreateLeaderboard' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_GetAchievement");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_GetAchievement");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUserStats_GetAchievement' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_GetAchievementAchievedPercent");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_GetAchievementAchievedPercent");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUserStats_GetAchievementAchievedPercent' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_GetAchievementAndUnlockTime");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_GetAchievementAndUnlockTime");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUserStats_GetAchievementAndUnlockTime' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_GetAchievementDisplayAttribute");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_GetAchievementDisplayAttribute");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUserStats_GetAchievementDisplayAttribute' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_GetAchievementIcon");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_GetAchievementIcon");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUserStats_GetAchievementIcon' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_GetAchievementName");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_GetAchievementName");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUserStats_GetAchievementName' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_GetAchievementProgressLimitsFloat");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_GetAchievementProgressLimitsFloat");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUserStats_GetAchievementProgressLimitsFloat' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_GetAchievementProgressLimitsInt32");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_GetAchievementProgressLimitsInt32");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUserStats_GetAchievementProgressLimitsInt32' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_GetDownloadedLeaderboardEntry");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_GetDownloadedLeaderboardEntry");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUserStats_GetDownloadedLeaderboardEntry' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_GetGlobalStat");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_GetGlobalStat");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUserStats_GetGlobalStat' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_GetGlobalStat0");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_GetGlobalStat0");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUserStats_GetGlobalStat0' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_GetGlobalStatDouble");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_GetGlobalStatDouble");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUserStats_GetGlobalStatDouble' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_GetGlobalStatHistory");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_GetGlobalStatHistory");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUserStats_GetGlobalStatHistory' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_GetGlobalStatHistory0");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_GetGlobalStatHistory0");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUserStats_GetGlobalStatHistory0' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_GetGlobalStatHistoryDouble");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_GetGlobalStatHistoryDouble");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUserStats_GetGlobalStatHistoryDouble' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_GetGlobalStatHistoryInt64");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_GetGlobalStatHistoryInt64");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUserStats_GetGlobalStatHistoryInt64' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_GetGlobalStatInt64");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_GetGlobalStatInt64");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUserStats_GetGlobalStatInt64' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_GetLeaderboardDisplayType");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_GetLeaderboardDisplayType");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUserStats_GetLeaderboardDisplayType' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_GetLeaderboardEntryCount");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_GetLeaderboardEntryCount");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUserStats_GetLeaderboardEntryCount' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_GetLeaderboardName");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_GetLeaderboardName");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUserStats_GetLeaderboardName' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_GetLeaderboardSortMethod");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_GetLeaderboardSortMethod");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUserStats_GetLeaderboardSortMethod' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_GetMostAchievedAchievementInfo");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_GetMostAchievedAchievementInfo");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUserStats_GetMostAchievedAchievementInfo' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_GetNextMostAchievedAchievementInfo");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_GetNextMostAchievedAchievementInfo");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUserStats_GetNextMostAchievedAchievementInfo' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_GetNumAchievements");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_GetNumAchievements");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUserStats_GetNumAchievements' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_GetNumberOfCurrentPlayers");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_GetNumberOfCurrentPlayers");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUserStats_GetNumberOfCurrentPlayers' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_GetStat");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_GetStat");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUserStats_GetStat' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_GetStat0");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_GetStat0");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUserStats_GetStat0' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_GetStatFloat");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_GetStatFloat");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUserStats_GetStatFloat' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_GetStatInt32");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_GetStatInt32");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUserStats_GetStatInt32' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_GetUserAchievement");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_GetUserAchievement");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUserStats_GetUserAchievement' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_GetUserAchievementAndUnlockTime");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_GetUserAchievementAndUnlockTime");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUserStats_GetUserAchievementAndUnlockTime' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_GetUserStat");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_GetUserStat");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUserStats_GetUserStat' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_GetUserStat0");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_GetUserStat0");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUserStats_GetUserStat0' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_GetUserStatFloat");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_GetUserStatFloat");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUserStats_GetUserStatFloat' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_GetUserStatInt32");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_GetUserStatInt32");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUserStats_GetUserStatInt32' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_IndicateAchievementProgress");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_IndicateAchievementProgress");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUserStats_IndicateAchievementProgress' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_RequestCurrentStats");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_RequestCurrentStats");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUserStats_RequestCurrentStats' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_RequestGlobalAchievementPercentages");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_RequestGlobalAchievementPercentages");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUserStats_RequestGlobalAchievementPercentages' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_RequestGlobalStats");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_RequestGlobalStats");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUserStats_RequestGlobalStats' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_RequestUserStats");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_RequestUserStats");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUserStats_RequestUserStats' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_ResetAllStats");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_ResetAllStats");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUserStats_ResetAllStats' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_SetAchievement");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_SetAchievement");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUserStats_SetAchievement' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_SetStat");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_SetStat");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUserStats_SetStat' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_SetStat0");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_SetStat0");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUserStats_SetStat0' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_SetStatFloat");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_SetStatFloat");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUserStats_SetStatFloat' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_SetStatInt32");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_SetStatInt32");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUserStats_SetStatInt32' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_StoreStats");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_StoreStats");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUserStats_StoreStats' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_UpdateAvgRateStat");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_UpdateAvgRateStat");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUserStats_UpdateAvgRateStat' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_UploadLeaderboardScore");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_UploadLeaderboardScore");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUserStats_UploadLeaderboardScore' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUser_AdvertiseGame");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUser_AdvertiseGame");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUser_AdvertiseGame' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUser_BIsBehindNAT");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUser_BIsBehindNAT");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUser_BIsBehindNAT' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUser_BIsPhoneIdentifying");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUser_BIsPhoneIdentifying");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUser_BIsPhoneIdentifying' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUser_BIsPhoneRequiringVerification");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUser_BIsPhoneRequiringVerification");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUser_BIsPhoneRequiringVerification' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUser_BIsPhoneVerified");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUser_BIsPhoneVerified");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUser_BIsPhoneVerified' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUser_BIsTwoFactorEnabled");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUser_BIsTwoFactorEnabled");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUser_BIsTwoFactorEnabled' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUser_BLoggedOn");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUser_BLoggedOn");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUser_BLoggedOn' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUser_BSetDurationControlOnlineState");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUser_BSetDurationControlOnlineState");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUser_BSetDurationControlOnlineState' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUser_BeginAuthSession");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUser_BeginAuthSession");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUser_BeginAuthSession' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUser_CancelAuthTicket");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUser_CancelAuthTicket");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUser_CancelAuthTicket' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUser_DecompressVoice");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUser_DecompressVoice");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUser_DecompressVoice' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUser_EndAuthSession");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUser_EndAuthSession");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUser_EndAuthSession' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUser_GetAuthSessionTicket");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUser_GetAuthSessionTicket");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUser_GetAuthSessionTicket' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUser_GetAuthTicketForWebApi");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUser_GetAuthTicketForWebApi");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUser_GetAuthTicketForWebApi' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUser_GetAvailableVoice");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUser_GetAvailableVoice");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUser_GetAvailableVoice' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUser_GetDurationControl");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUser_GetDurationControl");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUser_GetDurationControl' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUser_GetEncryptedAppTicket");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUser_GetEncryptedAppTicket");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUser_GetEncryptedAppTicket' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUser_GetGameBadgeLevel");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUser_GetGameBadgeLevel");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUser_GetGameBadgeLevel' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUser_GetHSteamUser");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUser_GetHSteamUser");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUser_GetHSteamUser' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUser_GetMarketEligibility");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUser_GetMarketEligibility");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUser_GetMarketEligibility' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUser_GetPlayerSteamLevel");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUser_GetPlayerSteamLevel");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUser_GetPlayerSteamLevel' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUser_GetSteamID");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUser_GetSteamID");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUser_GetSteamID' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUser_GetUserDataFolder");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUser_GetUserDataFolder");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUser_GetUserDataFolder' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUser_GetVoice");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUser_GetVoice");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUser_GetVoice' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUser_GetVoiceOptimalSampleRate");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUser_GetVoiceOptimalSampleRate");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUser_GetVoiceOptimalSampleRate' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUser_InitiateGameConnection");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUser_InitiateGameConnection");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUser_InitiateGameConnection' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUser_InitiateGameConnection_DEPRECATED");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUser_InitiateGameConnection_DEPRECATED");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUser_InitiateGameConnection_DEPRECATED' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUser_RequestEncryptedAppTicket");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUser_RequestEncryptedAppTicket");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUser_RequestEncryptedAppTicket' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUser_RequestStoreAuthURL");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUser_RequestStoreAuthURL");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUser_RequestStoreAuthURL' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUser_StartVoiceRecording");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUser_StartVoiceRecording");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUser_StartVoiceRecording' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUser_StopVoiceRecording");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUser_StopVoiceRecording");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUser_StopVoiceRecording' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUser_TerminateGameConnection");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUser_TerminateGameConnection");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUser_TerminateGameConnection' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUser_TerminateGameConnection_DEPRECATED");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUser_TerminateGameConnection_DEPRECATED");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUser_TerminateGameConnection_DEPRECATED' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUser_TrackAppUsageEvent");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUser_TrackAppUsageEvent");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUser_TrackAppUsageEvent' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUser_UserHasLicenseForApp");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUser_UserHasLicenseForApp");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUser_UserHasLicenseForApp' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUtils_BOverlayNeedsPresent");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUtils_BOverlayNeedsPresent");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUtils_BOverlayNeedsPresent' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUtils_CheckFileSignature");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUtils_CheckFileSignature");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUtils_CheckFileSignature' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUtils_DismissFloatingGamepadTextInput");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUtils_DismissFloatingGamepadTextInput");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUtils_DismissFloatingGamepadTextInput' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUtils_DismissGamepadTextInput");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUtils_DismissGamepadTextInput");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUtils_DismissGamepadTextInput' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUtils_FilterText");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUtils_FilterText");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUtils_FilterText' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUtils_GetAPICallFailureReason");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUtils_GetAPICallFailureReason");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUtils_GetAPICallFailureReason' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUtils_GetAPICallResult");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUtils_GetAPICallResult");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUtils_GetAPICallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUtils_GetAppID");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUtils_GetAppID");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUtils_GetAppID' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUtils_GetCSERIPPort");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUtils_GetCSERIPPort");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUtils_GetCSERIPPort' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUtils_GetConnectedUniverse");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUtils_GetConnectedUniverse");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUtils_GetConnectedUniverse' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUtils_GetCurrentBatteryPower");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUtils_GetCurrentBatteryPower");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUtils_GetCurrentBatteryPower' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUtils_GetEnteredGamepadTextInput");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUtils_GetEnteredGamepadTextInput");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUtils_GetEnteredGamepadTextInput' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUtils_GetEnteredGamepadTextLength");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUtils_GetEnteredGamepadTextLength");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUtils_GetEnteredGamepadTextLength' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUtils_GetIPCCallCount");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUtils_GetIPCCallCount");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUtils_GetIPCCallCount' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUtils_GetIPCountry");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUtils_GetIPCountry");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUtils_GetIPCountry' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUtils_GetIPv6ConnectivityState");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUtils_GetIPv6ConnectivityState");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUtils_GetIPv6ConnectivityState' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUtils_GetImageRGBA");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUtils_GetImageRGBA");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUtils_GetImageRGBA' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUtils_GetImageSize");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUtils_GetImageSize");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUtils_GetImageSize' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUtils_GetSecondsSinceAppActive");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUtils_GetSecondsSinceAppActive");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUtils_GetSecondsSinceAppActive' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUtils_GetSecondsSinceComputerActive");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUtils_GetSecondsSinceComputerActive");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUtils_GetSecondsSinceComputerActive' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUtils_GetServerRealTime");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUtils_GetServerRealTime");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUtils_GetServerRealTime' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUtils_GetSteamUILanguage");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUtils_GetSteamUILanguage");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUtils_GetSteamUILanguage' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUtils_InitFilterText");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUtils_InitFilterText");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUtils_InitFilterText' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUtils_IsAPICallCompleted");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUtils_IsAPICallCompleted");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUtils_IsAPICallCompleted' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUtils_IsOverlayEnabled");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUtils_IsOverlayEnabled");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUtils_IsOverlayEnabled' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUtils_IsSteamChinaLauncher");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUtils_IsSteamChinaLauncher");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUtils_IsSteamChinaLauncher' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUtils_IsSteamInBigPictureMode");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUtils_IsSteamInBigPictureMode");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUtils_IsSteamInBigPictureMode' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUtils_IsSteamRunningInVR");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUtils_IsSteamRunningInVR");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUtils_IsSteamRunningInVR' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUtils_IsSteamRunningOnSteamDeck");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUtils_IsSteamRunningOnSteamDeck");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUtils_IsSteamRunningOnSteamDeck' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUtils_IsVRHeadsetStreamingEnabled");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUtils_IsVRHeadsetStreamingEnabled");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUtils_IsVRHeadsetStreamingEnabled' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUtils_RunFrame");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUtils_RunFrame");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUtils_RunFrame' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUtils_SetGameLauncherMode");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUtils_SetGameLauncherMode");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUtils_SetGameLauncherMode' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUtils_SetOverlayNotificationInset");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUtils_SetOverlayNotificationInset");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUtils_SetOverlayNotificationInset' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUtils_SetOverlayNotificationPosition");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUtils_SetOverlayNotificationPosition");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUtils_SetOverlayNotificationPosition' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUtils_SetVRHeadsetStreamingEnabled");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUtils_SetVRHeadsetStreamingEnabled");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUtils_SetVRHeadsetStreamingEnabled' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUtils_SetWarningMessageHook");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUtils_SetWarningMessageHook");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUtils_SetWarningMessageHook' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUtils_ShowFloatingGamepadTextInput");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUtils_ShowFloatingGamepadTextInput");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUtils_ShowFloatingGamepadTextInput' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUtils_ShowGamepadTextInput");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUtils_ShowGamepadTextInput");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUtils_ShowGamepadTextInput' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUtils_ShowModalGamepadTextInput");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUtils_ShowModalGamepadTextInput");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUtils_ShowModalGamepadTextInput' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUtils_StartVRDashboard");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUtils_StartVRDashboard");
        LOG_TRACE("{} -> 'SteamAPI_ISteamUtils_StartVRDashboard' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamVideo_AddTimelineHighlightMarker");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamVideo_AddTimelineHighlightMarker");
        LOG_TRACE("{} -> 'SteamAPI_ISteamVideo_AddTimelineHighlightMarker' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamVideo_AddTimelineRange");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamVideo_AddTimelineRange");
        LOG_TRACE("{} -> 'SteamAPI_ISteamVideo_AddTimelineRange' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamVideo_AddTimelineRangeEnd");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamVideo_AddTimelineRangeEnd");
        LOG_TRACE("{} -> 'SteamAPI_ISteamVideo_AddTimelineRangeEnd' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamVideo_AddTimelineRangeStart");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamVideo_AddTimelineRangeStart");
        LOG_TRACE("{} -> 'SteamAPI_ISteamVideo_AddTimelineRangeStart' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamVideo_AddTimelineTimestamp");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamVideo_AddTimelineTimestamp");
        LOG_TRACE("{} -> 'SteamAPI_ISteamVideo_AddTimelineTimestamp' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamVideo_GetOPFSettings");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamVideo_GetOPFSettings");
        LOG_TRACE("{} -> 'SteamAPI_ISteamVideo_GetOPFSettings' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamVideo_GetOPFStringForApp");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamVideo_GetOPFStringForApp");
        LOG_TRACE("{} -> 'SteamAPI_ISteamVideo_GetOPFStringForApp' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamVideo_GetVideoURL");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamVideo_GetVideoURL");
        LOG_TRACE("{} -> 'SteamAPI_ISteamVideo_GetVideoURL' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamVideo_IsBroadcasting");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamVideo_IsBroadcasting");
        LOG_TRACE("{} -> 'SteamAPI_ISteamVideo_IsBroadcasting' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamVideo_SetTimelineGameMode");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamVideo_SetTimelineGameMode");
        LOG_TRACE("{} -> 'SteamAPI_ISteamVideo_SetTimelineGameMode' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_Init");
        src_address = dlsym(original_lib_handle, "SteamAPI_Init");
        LOG_TRACE("{} -> 'SteamAPI_Init' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_InitAnonymousUser");
        src_address = dlsym(original_lib_handle, "SteamAPI_InitAnonymousUser");
        LOG_TRACE("{} -> 'SteamAPI_InitAnonymousUser' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_InitFlat");
        src_address = dlsym(original_lib_handle, "SteamAPI_InitFlat");
        LOG_TRACE("{} -> 'SteamAPI_InitFlat' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_InitSafe");
        src_address = dlsym(original_lib_handle, "SteamAPI_InitSafe");
        LOG_TRACE("{} -> 'SteamAPI_InitSafe' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_IsSteamRunning");
        src_address = dlsym(original_lib_handle, "SteamAPI_IsSteamRunning");
        LOG_TRACE("{} -> 'SteamAPI_IsSteamRunning' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ManualDispatch_FreeLastCallback");
        src_address = dlsym(original_lib_handle, "SteamAPI_ManualDispatch_FreeLastCallback");
        LOG_TRACE("{} -> 'SteamAPI_ManualDispatch_FreeLastCallback' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ManualDispatch_GetAPICallResult");
        src_address = dlsym(original_lib_handle, "SteamAPI_ManualDispatch_GetAPICallResult");
        LOG_TRACE("{} -> 'SteamAPI_ManualDispatch_GetAPICallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ManualDispatch_GetNextCallback");
        src_address = dlsym(original_lib_handle, "SteamAPI_ManualDispatch_GetNextCallback");
        LOG_TRACE("{} -> 'SteamAPI_ManualDispatch_GetNextCallback' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ManualDispatch_Init");
        src_address = dlsym(original_lib_handle, "SteamAPI_ManualDispatch_Init");
        LOG_TRACE("{} -> 'SteamAPI_ManualDispatch_Init' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ManualDispatch_RunFrame");
        src_address = dlsym(original_lib_handle, "SteamAPI_ManualDispatch_RunFrame");
        LOG_TRACE("{} -> 'SteamAPI_ManualDispatch_RunFrame' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_MatchMakingKeyValuePair_t_Construct");
        src_address = dlsym(original_lib_handle, "SteamAPI_MatchMakingKeyValuePair_t_Construct");
        LOG_TRACE("{} -> 'SteamAPI_MatchMakingKeyValuePair_t_Construct' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_RegisterCallResult");
        src_address = dlsym(original_lib_handle, "SteamAPI_RegisterCallResult");
        LOG_TRACE("{} -> 'SteamAPI_RegisterCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_RegisterCallback");
        src_address = dlsym(original_lib_handle, "SteamAPI_RegisterCallback");
        LOG_TRACE("{} -> 'SteamAPI_RegisterCallback' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ReleaseCurrentThreadMemory");
        src_address = dlsym(original_lib_handle, "SteamAPI_ReleaseCurrentThreadMemory");
        LOG_TRACE("{} -> 'SteamAPI_ReleaseCurrentThreadMemory' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_RestartAppIfNecessary");
        src_address = dlsym(original_lib_handle, "SteamAPI_RestartAppIfNecessary");
        LOG_TRACE("{} -> 'SteamAPI_RestartAppIfNecessary' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_RunCallbacks");
        src_address = dlsym(original_lib_handle, "SteamAPI_RunCallbacks");
        LOG_TRACE("{} -> 'SteamAPI_RunCallbacks' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SetBreakpadAppID");
        src_address = dlsym(original_lib_handle, "SteamAPI_SetBreakpadAppID");
        LOG_TRACE("{} -> 'SteamAPI_SetBreakpadAppID' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SetMiniDumpComment");
        src_address = dlsym(original_lib_handle, "SteamAPI_SetMiniDumpComment");
        LOG_TRACE("{} -> 'SteamAPI_SetMiniDumpComment' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SetTryCatchCallbacks");
        src_address = dlsym(original_lib_handle, "SteamAPI_SetTryCatchCallbacks");
        LOG_TRACE("{} -> 'SteamAPI_SetTryCatchCallbacks' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_Shutdown");
        src_address = dlsym(original_lib_handle, "SteamAPI_Shutdown");
        LOG_TRACE("{} -> 'SteamAPI_Shutdown' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamAppList_v001");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamAppList_v001");
        LOG_TRACE("{} -> 'SteamAPI_SteamAppList_v001' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamApps_v008");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamApps_v008");
        LOG_TRACE("{} -> 'SteamAPI_SteamApps_v008' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamController_v007");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamController_v007");
        LOG_TRACE("{} -> 'SteamAPI_SteamController_v007' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamController_v008");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamController_v008");
        LOG_TRACE("{} -> 'SteamAPI_SteamController_v008' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamDatagramHostedAddress_Clear");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamDatagramHostedAddress_Clear");
        LOG_TRACE("{} -> 'SteamAPI_SteamDatagramHostedAddress_Clear' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamDatagramHostedAddress_GetPopID");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamDatagramHostedAddress_GetPopID");
        LOG_TRACE("{} -> 'SteamAPI_SteamDatagramHostedAddress_GetPopID' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamDatagramHostedAddress_SetDevAddress");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamDatagramHostedAddress_SetDevAddress");
        LOG_TRACE("{} -> 'SteamAPI_SteamDatagramHostedAddress_SetDevAddress' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamFriends_v017");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamFriends_v017");
        LOG_TRACE("{} -> 'SteamAPI_SteamFriends_v017' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamFriends_v018");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamFriends_v018");
        LOG_TRACE("{} -> 'SteamAPI_SteamFriends_v018' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamGameSearch_v001");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamGameSearch_v001");
        LOG_TRACE("{} -> 'SteamAPI_SteamGameSearch_v001' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamGameServerApps_v008");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamGameServerApps_v008");
        LOG_TRACE("{} -> 'SteamAPI_SteamGameServerApps_v008' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamGameServerHTTP_v003");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamGameServerHTTP_v003");
        LOG_TRACE("{} -> 'SteamAPI_SteamGameServerHTTP_v003' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamGameServerInventory_v003");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamGameServerInventory_v003");
        LOG_TRACE("{} -> 'SteamAPI_SteamGameServerInventory_v003' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamGameServerNetworkingMessages_SteamAPI_v002");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamGameServerNetworkingMessages_SteamAPI_v002");
        LOG_TRACE("{} -> 'SteamAPI_SteamGameServerNetworkingMessages_SteamAPI_v002' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamGameServerNetworkingMessages_v002");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamGameServerNetworkingMessages_v002");
        LOG_TRACE("{} -> 'SteamAPI_SteamGameServerNetworkingMessages_v002' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamGameServerNetworkingSockets_SteamAPI_v009");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamGameServerNetworkingSockets_SteamAPI_v009");
        LOG_TRACE("{} -> 'SteamAPI_SteamGameServerNetworkingSockets_SteamAPI_v009' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamGameServerNetworkingSockets_SteamAPI_v011");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamGameServerNetworkingSockets_SteamAPI_v011");
        LOG_TRACE("{} -> 'SteamAPI_SteamGameServerNetworkingSockets_SteamAPI_v011' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamGameServerNetworkingSockets_SteamAPI_v012");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamGameServerNetworkingSockets_SteamAPI_v012");
        LOG_TRACE("{} -> 'SteamAPI_SteamGameServerNetworkingSockets_SteamAPI_v012' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamGameServerNetworkingSockets_v008");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamGameServerNetworkingSockets_v008");
        LOG_TRACE("{} -> 'SteamAPI_SteamGameServerNetworkingSockets_v008' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamGameServerNetworkingSockets_v009");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamGameServerNetworkingSockets_v009");
        LOG_TRACE("{} -> 'SteamAPI_SteamGameServerNetworkingSockets_v009' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamGameServerNetworking_v006");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamGameServerNetworking_v006");
        LOG_TRACE("{} -> 'SteamAPI_SteamGameServerNetworking_v006' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamGameServerStats_v001");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamGameServerStats_v001");
        LOG_TRACE("{} -> 'SteamAPI_SteamGameServerStats_v001' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamGameServerUGC_v014");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamGameServerUGC_v014");
        LOG_TRACE("{} -> 'SteamAPI_SteamGameServerUGC_v014' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamGameServerUGC_v015");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamGameServerUGC_v015");
        LOG_TRACE("{} -> 'SteamAPI_SteamGameServerUGC_v015' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamGameServerUGC_v016");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamGameServerUGC_v016");
        LOG_TRACE("{} -> 'SteamAPI_SteamGameServerUGC_v016' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamGameServerUGC_v017");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamGameServerUGC_v017");
        LOG_TRACE("{} -> 'SteamAPI_SteamGameServerUGC_v017' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamGameServerUGC_v018");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamGameServerUGC_v018");
        LOG_TRACE("{} -> 'SteamAPI_SteamGameServerUGC_v018' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamGameServerUGC_v020");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamGameServerUGC_v020");
        LOG_TRACE("{} -> 'SteamAPI_SteamGameServerUGC_v020' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamGameServerUGC_v021");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamGameServerUGC_v021");
        LOG_TRACE("{} -> 'SteamAPI_SteamGameServerUGC_v021' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamGameServerUtils_v009");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamGameServerUtils_v009");
        LOG_TRACE("{} -> 'SteamAPI_SteamGameServerUtils_v009' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamGameServerUtils_v010");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamGameServerUtils_v010");
        LOG_TRACE("{} -> 'SteamAPI_SteamGameServerUtils_v010' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamGameServer_v013");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamGameServer_v013");
        LOG_TRACE("{} -> 'SteamAPI_SteamGameServer_v013' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamGameServer_v014");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamGameServer_v014");
        LOG_TRACE("{} -> 'SteamAPI_SteamGameServer_v014' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamGameServer_v015");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamGameServer_v015");
        LOG_TRACE("{} -> 'SteamAPI_SteamGameServer_v015' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamHTMLSurface_v005");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamHTMLSurface_v005");
        LOG_TRACE("{} -> 'SteamAPI_SteamHTMLSurface_v005' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamHTTP_v003");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamHTTP_v003");
        LOG_TRACE("{} -> 'SteamAPI_SteamHTTP_v003' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamIPAddress_t_IsSet");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamIPAddress_t_IsSet");
        LOG_TRACE("{} -> 'SteamAPI_SteamIPAddress_t_IsSet' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamInput_v001");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamInput_v001");
        LOG_TRACE("{} -> 'SteamAPI_SteamInput_v001' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamInput_v002");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamInput_v002");
        LOG_TRACE("{} -> 'SteamAPI_SteamInput_v002' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamInput_v005");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamInput_v005");
        LOG_TRACE("{} -> 'SteamAPI_SteamInput_v005' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamInput_v006");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamInput_v006");
        LOG_TRACE("{} -> 'SteamAPI_SteamInput_v006' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamInventory_v003");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamInventory_v003");
        LOG_TRACE("{} -> 'SteamAPI_SteamInventory_v003' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamMatchmakingServers_v002");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamMatchmakingServers_v002");
        LOG_TRACE("{} -> 'SteamAPI_SteamMatchmakingServers_v002' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamMatchmaking_v009");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamMatchmaking_v009");
        LOG_TRACE("{} -> 'SteamAPI_SteamMatchmaking_v009' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamMusicRemote_v001");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamMusicRemote_v001");
        LOG_TRACE("{} -> 'SteamAPI_SteamMusicRemote_v001' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamMusic_v001");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamMusic_v001");
        LOG_TRACE("{} -> 'SteamAPI_SteamMusic_v001' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingConfigValue_t_SetFloat");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingConfigValue_t_SetFloat");
        LOG_TRACE("{} -> 'SteamAPI_SteamNetworkingConfigValue_t_SetFloat' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingConfigValue_t_SetInt32");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingConfigValue_t_SetInt32");
        LOG_TRACE("{} -> 'SteamAPI_SteamNetworkingConfigValue_t_SetInt32' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingConfigValue_t_SetInt64");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingConfigValue_t_SetInt64");
        LOG_TRACE("{} -> 'SteamAPI_SteamNetworkingConfigValue_t_SetInt64' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingConfigValue_t_SetPtr");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingConfigValue_t_SetPtr");
        LOG_TRACE("{} -> 'SteamAPI_SteamNetworkingConfigValue_t_SetPtr' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingConfigValue_t_SetString");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingConfigValue_t_SetString");
        LOG_TRACE("{} -> 'SteamAPI_SteamNetworkingConfigValue_t_SetString' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingIPAddrRender_c_str");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingIPAddrRender_c_str");
        LOG_TRACE("{} -> 'SteamAPI_SteamNetworkingIPAddrRender_c_str' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingIPAddr_Clear");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingIPAddr_Clear");
        LOG_TRACE("{} -> 'SteamAPI_SteamNetworkingIPAddr_Clear' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingIPAddr_GetFakeIPType");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingIPAddr_GetFakeIPType");
        LOG_TRACE("{} -> 'SteamAPI_SteamNetworkingIPAddr_GetFakeIPType' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingIPAddr_GetIPv4");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingIPAddr_GetIPv4");
        LOG_TRACE("{} -> 'SteamAPI_SteamNetworkingIPAddr_GetIPv4' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingIPAddr_IsEqualTo");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingIPAddr_IsEqualTo");
        LOG_TRACE("{} -> 'SteamAPI_SteamNetworkingIPAddr_IsEqualTo' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingIPAddr_IsFakeIP");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingIPAddr_IsFakeIP");
        LOG_TRACE("{} -> 'SteamAPI_SteamNetworkingIPAddr_IsFakeIP' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingIPAddr_IsIPv4");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingIPAddr_IsIPv4");
        LOG_TRACE("{} -> 'SteamAPI_SteamNetworkingIPAddr_IsIPv4' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingIPAddr_IsIPv6AllZeros");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingIPAddr_IsIPv6AllZeros");
        LOG_TRACE("{} -> 'SteamAPI_SteamNetworkingIPAddr_IsIPv6AllZeros' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingIPAddr_IsLocalHost");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingIPAddr_IsLocalHost");
        LOG_TRACE("{} -> 'SteamAPI_SteamNetworkingIPAddr_IsLocalHost' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingIPAddr_ParseString");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingIPAddr_ParseString");
        LOG_TRACE("{} -> 'SteamAPI_SteamNetworkingIPAddr_ParseString' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingIPAddr_SetIPv4");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingIPAddr_SetIPv4");
        LOG_TRACE("{} -> 'SteamAPI_SteamNetworkingIPAddr_SetIPv4' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingIPAddr_SetIPv6");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingIPAddr_SetIPv6");
        LOG_TRACE("{} -> 'SteamAPI_SteamNetworkingIPAddr_SetIPv6' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingIPAddr_SetIPv6LocalHost");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingIPAddr_SetIPv6LocalHost");
        LOG_TRACE("{} -> 'SteamAPI_SteamNetworkingIPAddr_SetIPv6LocalHost' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingIPAddr_ToString");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingIPAddr_ToString");
        LOG_TRACE("{} -> 'SteamAPI_SteamNetworkingIPAddr_ToString' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingIdentityRender_c_str");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingIdentityRender_c_str");
        LOG_TRACE("{} -> 'SteamAPI_SteamNetworkingIdentityRender_c_str' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingIdentity_Clear");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingIdentity_Clear");
        LOG_TRACE("{} -> 'SteamAPI_SteamNetworkingIdentity_Clear' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingIdentity_GetFakeIPType");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingIdentity_GetFakeIPType");
        LOG_TRACE("{} -> 'SteamAPI_SteamNetworkingIdentity_GetFakeIPType' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingIdentity_GetGenericBytes");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingIdentity_GetGenericBytes");
        LOG_TRACE("{} -> 'SteamAPI_SteamNetworkingIdentity_GetGenericBytes' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingIdentity_GetGenericString");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingIdentity_GetGenericString");
        LOG_TRACE("{} -> 'SteamAPI_SteamNetworkingIdentity_GetGenericString' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingIdentity_GetIPAddr");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingIdentity_GetIPAddr");
        LOG_TRACE("{} -> 'SteamAPI_SteamNetworkingIdentity_GetIPAddr' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingIdentity_GetIPv4");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingIdentity_GetIPv4");
        LOG_TRACE("{} -> 'SteamAPI_SteamNetworkingIdentity_GetIPv4' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingIdentity_GetPSNID");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingIdentity_GetPSNID");
        LOG_TRACE("{} -> 'SteamAPI_SteamNetworkingIdentity_GetPSNID' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingIdentity_GetStadiaID");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingIdentity_GetStadiaID");
        LOG_TRACE("{} -> 'SteamAPI_SteamNetworkingIdentity_GetStadiaID' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingIdentity_GetSteamID");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingIdentity_GetSteamID");
        LOG_TRACE("{} -> 'SteamAPI_SteamNetworkingIdentity_GetSteamID' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingIdentity_GetSteamID64");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingIdentity_GetSteamID64");
        LOG_TRACE("{} -> 'SteamAPI_SteamNetworkingIdentity_GetSteamID64' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingIdentity_GetXboxPairwiseID");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingIdentity_GetXboxPairwiseID");
        LOG_TRACE("{} -> 'SteamAPI_SteamNetworkingIdentity_GetXboxPairwiseID' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingIdentity_IsEqualTo");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingIdentity_IsEqualTo");
        LOG_TRACE("{} -> 'SteamAPI_SteamNetworkingIdentity_IsEqualTo' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingIdentity_IsFakeIP");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingIdentity_IsFakeIP");
        LOG_TRACE("{} -> 'SteamAPI_SteamNetworkingIdentity_IsFakeIP' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingIdentity_IsInvalid");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingIdentity_IsInvalid");
        LOG_TRACE("{} -> 'SteamAPI_SteamNetworkingIdentity_IsInvalid' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingIdentity_IsLocalHost");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingIdentity_IsLocalHost");
        LOG_TRACE("{} -> 'SteamAPI_SteamNetworkingIdentity_IsLocalHost' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingIdentity_ParseString");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingIdentity_ParseString");
        LOG_TRACE("{} -> 'SteamAPI_SteamNetworkingIdentity_ParseString' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingIdentity_SetGenericBytes");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingIdentity_SetGenericBytes");
        LOG_TRACE("{} -> 'SteamAPI_SteamNetworkingIdentity_SetGenericBytes' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingIdentity_SetGenericString");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingIdentity_SetGenericString");
        LOG_TRACE("{} -> 'SteamAPI_SteamNetworkingIdentity_SetGenericString' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingIdentity_SetIPAddr");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingIdentity_SetIPAddr");
        LOG_TRACE("{} -> 'SteamAPI_SteamNetworkingIdentity_SetIPAddr' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingIdentity_SetIPv4Addr");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingIdentity_SetIPv4Addr");
        LOG_TRACE("{} -> 'SteamAPI_SteamNetworkingIdentity_SetIPv4Addr' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingIdentity_SetLocalHost");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingIdentity_SetLocalHost");
        LOG_TRACE("{} -> 'SteamAPI_SteamNetworkingIdentity_SetLocalHost' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingIdentity_SetPSNID");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingIdentity_SetPSNID");
        LOG_TRACE("{} -> 'SteamAPI_SteamNetworkingIdentity_SetPSNID' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingIdentity_SetStadiaID");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingIdentity_SetStadiaID");
        LOG_TRACE("{} -> 'SteamAPI_SteamNetworkingIdentity_SetStadiaID' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingIdentity_SetSteamID");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingIdentity_SetSteamID");
        LOG_TRACE("{} -> 'SteamAPI_SteamNetworkingIdentity_SetSteamID' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingIdentity_SetSteamID64");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingIdentity_SetSteamID64");
        LOG_TRACE("{} -> 'SteamAPI_SteamNetworkingIdentity_SetSteamID64' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingIdentity_SetXboxPairwiseID");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingIdentity_SetXboxPairwiseID");
        LOG_TRACE("{} -> 'SteamAPI_SteamNetworkingIdentity_SetXboxPairwiseID' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingIdentity_ToString");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingIdentity_ToString");
        LOG_TRACE("{} -> 'SteamAPI_SteamNetworkingIdentity_ToString' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingMessage_t_Release");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingMessage_t_Release");
        LOG_TRACE("{} -> 'SteamAPI_SteamNetworkingMessage_t_Release' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingMessages_SteamAPI_v002");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingMessages_SteamAPI_v002");
        LOG_TRACE("{} -> 'SteamAPI_SteamNetworkingMessages_SteamAPI_v002' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingMessages_v002");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingMessages_v002");
        LOG_TRACE("{} -> 'SteamAPI_SteamNetworkingMessages_v002' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingPOPIDRender_c_str");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingPOPIDRender_c_str");
        LOG_TRACE("{} -> 'SteamAPI_SteamNetworkingPOPIDRender_c_str' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingSockets_SteamAPI_v009");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingSockets_SteamAPI_v009");
        LOG_TRACE("{} -> 'SteamAPI_SteamNetworkingSockets_SteamAPI_v009' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingSockets_SteamAPI_v011");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingSockets_SteamAPI_v011");
        LOG_TRACE("{} -> 'SteamAPI_SteamNetworkingSockets_SteamAPI_v011' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingSockets_SteamAPI_v012");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingSockets_SteamAPI_v012");
        LOG_TRACE("{} -> 'SteamAPI_SteamNetworkingSockets_SteamAPI_v012' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingSockets_v008");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingSockets_v008");
        LOG_TRACE("{} -> 'SteamAPI_SteamNetworkingSockets_v008' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingSockets_v009");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingSockets_v009");
        LOG_TRACE("{} -> 'SteamAPI_SteamNetworkingSockets_v009' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingUtils_SteamAPI_v003");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingUtils_SteamAPI_v003");
        LOG_TRACE("{} -> 'SteamAPI_SteamNetworkingUtils_SteamAPI_v003' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingUtils_SteamAPI_v004");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingUtils_SteamAPI_v004");
        LOG_TRACE("{} -> 'SteamAPI_SteamNetworkingUtils_SteamAPI_v004' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingUtils_v003");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingUtils_v003");
        LOG_TRACE("{} -> 'SteamAPI_SteamNetworkingUtils_v003' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworking_v006");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworking_v006");
        LOG_TRACE("{} -> 'SteamAPI_SteamNetworking_v006' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamParentalSettings_v001");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamParentalSettings_v001");
        LOG_TRACE("{} -> 'SteamAPI_SteamParentalSettings_v001' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamParties_v002");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamParties_v002");
        LOG_TRACE("{} -> 'SteamAPI_SteamParties_v002' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamRemotePlay_v001");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamRemotePlay_v001");
        LOG_TRACE("{} -> 'SteamAPI_SteamRemotePlay_v001' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamRemotePlay_v002");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamRemotePlay_v002");
        LOG_TRACE("{} -> 'SteamAPI_SteamRemotePlay_v002' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamRemotePlay_v003");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamRemotePlay_v003");
        LOG_TRACE("{} -> 'SteamAPI_SteamRemotePlay_v003' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamRemoteStorage_v014");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamRemoteStorage_v014");
        LOG_TRACE("{} -> 'SteamAPI_SteamRemoteStorage_v014' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamRemoteStorage_v016");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamRemoteStorage_v016");
        LOG_TRACE("{} -> 'SteamAPI_SteamRemoteStorage_v016' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamScreenshots_v003");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamScreenshots_v003");
        LOG_TRACE("{} -> 'SteamAPI_SteamScreenshots_v003' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamTV_v001");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamTV_v001");
        LOG_TRACE("{} -> 'SteamAPI_SteamTV_v001' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamTimeline_v001");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamTimeline_v001");
        LOG_TRACE("{} -> 'SteamAPI_SteamTimeline_v001' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamTimeline_v004");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamTimeline_v004");
        LOG_TRACE("{} -> 'SteamAPI_SteamTimeline_v004' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamUGC_v014");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamUGC_v014");
        LOG_TRACE("{} -> 'SteamAPI_SteamUGC_v014' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamUGC_v015");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamUGC_v015");
        LOG_TRACE("{} -> 'SteamAPI_SteamUGC_v015' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamUGC_v016");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamUGC_v016");
        LOG_TRACE("{} -> 'SteamAPI_SteamUGC_v016' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamUGC_v017");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamUGC_v017");
        LOG_TRACE("{} -> 'SteamAPI_SteamUGC_v017' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamUGC_v018");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamUGC_v018");
        LOG_TRACE("{} -> 'SteamAPI_SteamUGC_v018' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamUGC_v020");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamUGC_v020");
        LOG_TRACE("{} -> 'SteamAPI_SteamUGC_v020' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamUGC_v021");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamUGC_v021");
        LOG_TRACE("{} -> 'SteamAPI_SteamUGC_v021' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamUserStats_v011");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamUserStats_v011");
        LOG_TRACE("{} -> 'SteamAPI_SteamUserStats_v011' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamUserStats_v012");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamUserStats_v012");
        LOG_TRACE("{} -> 'SteamAPI_SteamUserStats_v012' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamUserStats_v013");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamUserStats_v013");
        LOG_TRACE("{} -> 'SteamAPI_SteamUserStats_v013' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamUser_v020");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamUser_v020");
        LOG_TRACE("{} -> 'SteamAPI_SteamUser_v020' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamUser_v021");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamUser_v021");
        LOG_TRACE("{} -> 'SteamAPI_SteamUser_v021' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamUser_v022");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamUser_v022");
        LOG_TRACE("{} -> 'SteamAPI_SteamUser_v022' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamUser_v023");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamUser_v023");
        LOG_TRACE("{} -> 'SteamAPI_SteamUser_v023' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamUtils_v009");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamUtils_v009");
        LOG_TRACE("{} -> 'SteamAPI_SteamUtils_v009' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamUtils_v010");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamUtils_v010");
        LOG_TRACE("{} -> 'SteamAPI_SteamUtils_v010' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamVideo_v002");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamVideo_v002");
        LOG_TRACE("{} -> 'SteamAPI_SteamVideo_v002' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamVideo_v003");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamVideo_v003");
        LOG_TRACE("{} -> 'SteamAPI_SteamVideo_v003' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamVideo_v004");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamVideo_v004");
        LOG_TRACE("{} -> 'SteamAPI_SteamVideo_v004' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamVideo_v007");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamVideo_v007");
        LOG_TRACE("{} -> 'SteamAPI_SteamVideo_v007' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_UnregisterCallResult");
        src_address = dlsym(original_lib_handle, "SteamAPI_UnregisterCallResult");
        LOG_TRACE("{} -> 'SteamAPI_UnregisterCallResult' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_UnregisterCallback");
        src_address = dlsym(original_lib_handle, "SteamAPI_UnregisterCallback");
        LOG_TRACE("{} -> 'SteamAPI_UnregisterCallback' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_UseBreakpadCrashHandler");
        src_address = dlsym(original_lib_handle, "SteamAPI_UseBreakpadCrashHandler");
        LOG_TRACE("{} -> 'SteamAPI_UseBreakpadCrashHandler' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_WriteMiniDump");
        src_address = dlsym(original_lib_handle, "SteamAPI_WriteMiniDump");
        LOG_TRACE("{} -> 'SteamAPI_WriteMiniDump' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_gameserveritem_t_Construct");
        src_address = dlsym(original_lib_handle, "SteamAPI_gameserveritem_t_Construct");
        LOG_TRACE("{} -> 'SteamAPI_gameserveritem_t_Construct' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_gameserveritem_t_GetName");
        src_address = dlsym(original_lib_handle, "SteamAPI_gameserveritem_t_GetName");
        LOG_TRACE("{} -> 'SteamAPI_gameserveritem_t_GetName' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_gameserveritem_t_SetName");
        src_address = dlsym(original_lib_handle, "SteamAPI_gameserveritem_t_SetName");
        LOG_TRACE("{} -> 'SteamAPI_gameserveritem_t_SetName' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_servernetadr_t_Assign");
        src_address = dlsym(original_lib_handle, "SteamAPI_servernetadr_t_Assign");
        LOG_TRACE("{} -> 'SteamAPI_servernetadr_t_Assign' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_servernetadr_t_Construct");
        src_address = dlsym(original_lib_handle, "SteamAPI_servernetadr_t_Construct");
        LOG_TRACE("{} -> 'SteamAPI_servernetadr_t_Construct' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_servernetadr_t_GetConnectionAddressString");
        src_address = dlsym(original_lib_handle, "SteamAPI_servernetadr_t_GetConnectionAddressString");
        LOG_TRACE("{} -> 'SteamAPI_servernetadr_t_GetConnectionAddressString' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_servernetadr_t_GetConnectionPort");
        src_address = dlsym(original_lib_handle, "SteamAPI_servernetadr_t_GetConnectionPort");
        LOG_TRACE("{} -> 'SteamAPI_servernetadr_t_GetConnectionPort' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_servernetadr_t_GetIP");
        src_address = dlsym(original_lib_handle, "SteamAPI_servernetadr_t_GetIP");
        LOG_TRACE("{} -> 'SteamAPI_servernetadr_t_GetIP' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_servernetadr_t_GetQueryAddressString");
        src_address = dlsym(original_lib_handle, "SteamAPI_servernetadr_t_GetQueryAddressString");
        LOG_TRACE("{} -> 'SteamAPI_servernetadr_t_GetQueryAddressString' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_servernetadr_t_GetQueryPort");
        src_address = dlsym(original_lib_handle, "SteamAPI_servernetadr_t_GetQueryPort");
        LOG_TRACE("{} -> 'SteamAPI_servernetadr_t_GetQueryPort' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_servernetadr_t_Init");
        src_address = dlsym(original_lib_handle, "SteamAPI_servernetadr_t_Init");
        LOG_TRACE("{} -> 'SteamAPI_servernetadr_t_Init' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_servernetadr_t_IsLessThan");
        src_address = dlsym(original_lib_handle, "SteamAPI_servernetadr_t_IsLessThan");
        LOG_TRACE("{} -> 'SteamAPI_servernetadr_t_IsLessThan' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_servernetadr_t_SetConnectionPort");
        src_address = dlsym(original_lib_handle, "SteamAPI_servernetadr_t_SetConnectionPort");
        LOG_TRACE("{} -> 'SteamAPI_servernetadr_t_SetConnectionPort' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_servernetadr_t_SetIP");
        src_address = dlsym(original_lib_handle, "SteamAPI_servernetadr_t_SetIP");
        LOG_TRACE("{} -> 'SteamAPI_servernetadr_t_SetIP' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_servernetadr_t_SetQueryPort");
        src_address = dlsym(original_lib_handle, "SteamAPI_servernetadr_t_SetQueryPort");
        LOG_TRACE("{} -> 'SteamAPI_servernetadr_t_SetQueryPort' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAppList");
        src_address = dlsym(original_lib_handle, "SteamAppList");
        LOG_TRACE("{} -> 'SteamAppList' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamApps");
        src_address = dlsym(original_lib_handle, "SteamApps");
        LOG_TRACE("{} -> 'SteamApps' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamClient");
        src_address = dlsym(original_lib_handle, "SteamClient");
        LOG_TRACE("{} -> 'SteamClient' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamContentServer");
        src_address = dlsym(original_lib_handle, "SteamContentServer");
        LOG_TRACE("{} -> 'SteamContentServer' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamContentServerUtils");
        src_address = dlsym(original_lib_handle, "SteamContentServerUtils");
        LOG_TRACE("{} -> 'SteamContentServerUtils' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamContentServer_Init");
        src_address = dlsym(original_lib_handle, "SteamContentServer_Init");
        LOG_TRACE("{} -> 'SteamContentServer_Init' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamContentServer_RunCallbacks");
        src_address = dlsym(original_lib_handle, "SteamContentServer_RunCallbacks");
        LOG_TRACE("{} -> 'SteamContentServer_RunCallbacks' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamContentServer_Shutdown");
        src_address = dlsym(original_lib_handle, "SteamContentServer_Shutdown");
        LOG_TRACE("{} -> 'SteamContentServer_Shutdown' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamController");
        src_address = dlsym(original_lib_handle, "SteamController");
        LOG_TRACE("{} -> 'SteamController' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamController_GetControllerState");
        src_address = dlsym(original_lib_handle, "SteamController_GetControllerState");
        LOG_TRACE("{} -> 'SteamController_GetControllerState' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamController_Init");
        src_address = dlsym(original_lib_handle, "SteamController_Init");
        LOG_TRACE("{} -> 'SteamController_Init' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamController_SetOverrideMode");
        src_address = dlsym(original_lib_handle, "SteamController_SetOverrideMode");
        LOG_TRACE("{} -> 'SteamController_SetOverrideMode' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamController_Shutdown");
        src_address = dlsym(original_lib_handle, "SteamController_Shutdown");
        LOG_TRACE("{} -> 'SteamController_Shutdown' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamController_TriggerHapticPulse");
        src_address = dlsym(original_lib_handle, "SteamController_TriggerHapticPulse");
        LOG_TRACE("{} -> 'SteamController_TriggerHapticPulse' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamFriends");
        src_address = dlsym(original_lib_handle, "SteamFriends");
        LOG_TRACE("{} -> 'SteamFriends' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamGameServer");
        src_address = dlsym(original_lib_handle, "SteamGameServer");
        LOG_TRACE("{} -> 'SteamGameServer' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamGameServerApps");
        src_address = dlsym(original_lib_handle, "SteamGameServerApps");
        LOG_TRACE("{} -> 'SteamGameServerApps' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamGameServerHTTP");
        src_address = dlsym(original_lib_handle, "SteamGameServerHTTP");
        LOG_TRACE("{} -> 'SteamGameServerHTTP' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamGameServerInventory");
        src_address = dlsym(original_lib_handle, "SteamGameServerInventory");
        LOG_TRACE("{} -> 'SteamGameServerInventory' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamGameServerNetworking");
        src_address = dlsym(original_lib_handle, "SteamGameServerNetworking");
        LOG_TRACE("{} -> 'SteamGameServerNetworking' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamGameServerStats");
        src_address = dlsym(original_lib_handle, "SteamGameServerStats");
        LOG_TRACE("{} -> 'SteamGameServerStats' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamGameServerUGC");
        src_address = dlsym(original_lib_handle, "SteamGameServerUGC");
        LOG_TRACE("{} -> 'SteamGameServerUGC' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamGameServerUtils");
        src_address = dlsym(original_lib_handle, "SteamGameServerUtils");
        LOG_TRACE("{} -> 'SteamGameServerUtils' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamGameServer_BSecure");
        src_address = dlsym(original_lib_handle, "SteamGameServer_BSecure");
        LOG_TRACE("{} -> 'SteamGameServer_BSecure' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamGameServer_GetHSteamPipe");
        src_address = dlsym(original_lib_handle, "SteamGameServer_GetHSteamPipe");
        LOG_TRACE("{} -> 'SteamGameServer_GetHSteamPipe' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamGameServer_GetHSteamUser");
        src_address = dlsym(original_lib_handle, "SteamGameServer_GetHSteamUser");
        LOG_TRACE("{} -> 'SteamGameServer_GetHSteamUser' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamGameServer_GetIPCCallCount");
        src_address = dlsym(original_lib_handle, "SteamGameServer_GetIPCCallCount");
        LOG_TRACE("{} -> 'SteamGameServer_GetIPCCallCount' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamGameServer_GetSteamID");
        src_address = dlsym(original_lib_handle, "SteamGameServer_GetSteamID");
        LOG_TRACE("{} -> 'SteamGameServer_GetSteamID' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamGameServer_Init");
        src_address = dlsym(original_lib_handle, "SteamGameServer_Init");
        LOG_TRACE("{} -> 'SteamGameServer_Init' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamGameServer_InitSafe");
        src_address = dlsym(original_lib_handle, "SteamGameServer_InitSafe");
        LOG_TRACE("{} -> 'SteamGameServer_InitSafe' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamGameServer_RunCallbacks");
        src_address = dlsym(original_lib_handle, "SteamGameServer_RunCallbacks");
        LOG_TRACE("{} -> 'SteamGameServer_RunCallbacks' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamGameServer_Shutdown");
        src_address = dlsym(original_lib_handle, "SteamGameServer_Shutdown");
        LOG_TRACE("{} -> 'SteamGameServer_Shutdown' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamHTMLSurface");
        src_address = dlsym(original_lib_handle, "SteamHTMLSurface");
        LOG_TRACE("{} -> 'SteamHTMLSurface' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamHTTP");
        src_address = dlsym(original_lib_handle, "SteamHTTP");
        LOG_TRACE("{} -> 'SteamHTTP' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamInternal_ContextInit");
        src_address = dlsym(original_lib_handle, "SteamInternal_ContextInit");
        LOG_TRACE("{} -> 'SteamInternal_ContextInit' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamInternal_CreateInterface");
        src_address = dlsym(original_lib_handle, "SteamInternal_CreateInterface");
        LOG_TRACE("{} -> 'SteamInternal_CreateInterface' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamInternal_FindOrCreateGameServerInterface");
        src_address = dlsym(original_lib_handle, "SteamInternal_FindOrCreateGameServerInterface");
        LOG_TRACE("{} -> 'SteamInternal_FindOrCreateGameServerInterface' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamInternal_FindOrCreateUserInterface");
        src_address = dlsym(original_lib_handle, "SteamInternal_FindOrCreateUserInterface");
        LOG_TRACE("{} -> 'SteamInternal_FindOrCreateUserInterface' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamInternal_GameServer_Init");
        src_address = dlsym(original_lib_handle, "SteamInternal_GameServer_Init");
        LOG_TRACE("{} -> 'SteamInternal_GameServer_Init' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamInternal_GameServer_Init_V2");
        src_address = dlsym(original_lib_handle, "SteamInternal_GameServer_Init_V2");
        LOG_TRACE("{} -> 'SteamInternal_GameServer_Init_V2' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamInternal_GlobalContextGameServerPtr");
        src_address = dlsym(original_lib_handle, "SteamInternal_GlobalContextGameServerPtr");
        LOG_TRACE("{} -> 'SteamInternal_GlobalContextGameServerPtr' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamInternal_SteamAPI_Init");
        src_address = dlsym(original_lib_handle, "SteamInternal_SteamAPI_Init");
        LOG_TRACE("{} -> 'SteamInternal_SteamAPI_Init' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamInventory");
        src_address = dlsym(original_lib_handle, "SteamInventory");
        LOG_TRACE("{} -> 'SteamInventory' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamMatchmaking");
        src_address = dlsym(original_lib_handle, "SteamMatchmaking");
        LOG_TRACE("{} -> 'SteamMatchmaking' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamMatchmakingServers");
        src_address = dlsym(original_lib_handle, "SteamMatchmakingServers");
        LOG_TRACE("{} -> 'SteamMatchmakingServers' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamMusic");
        src_address = dlsym(original_lib_handle, "SteamMusic");
        LOG_TRACE("{} -> 'SteamMusic' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamMusicRemote");
        src_address = dlsym(original_lib_handle, "SteamMusicRemote");
        LOG_TRACE("{} -> 'SteamMusicRemote' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamNetworking");
        src_address = dlsym(original_lib_handle, "SteamNetworking");
        LOG_TRACE("{} -> 'SteamNetworking' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamRealPath");
        src_address = dlsym(original_lib_handle, "SteamRealPath");
        LOG_TRACE("{} -> 'SteamRealPath' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamRemoteStorage");
        src_address = dlsym(original_lib_handle, "SteamRemoteStorage");
        LOG_TRACE("{} -> 'SteamRemoteStorage' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamScreenshots");
        src_address = dlsym(original_lib_handle, "SteamScreenshots");
        LOG_TRACE("{} -> 'SteamScreenshots' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamUGC");
        src_address = dlsym(original_lib_handle, "SteamUGC");
        LOG_TRACE("{} -> 'SteamUGC' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamUnifiedMessages");
        src_address = dlsym(original_lib_handle, "SteamUnifiedMessages");
        LOG_TRACE("{} -> 'SteamUnifiedMessages' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamUser");
        src_address = dlsym(original_lib_handle, "SteamUser");
        LOG_TRACE("{} -> 'SteamUser' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamUserStats");
        src_address = dlsym(original_lib_handle, "SteamUserStats");
        LOG_TRACE("{} -> 'SteamUserStats' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamUtils");
        src_address = dlsym(original_lib_handle, "SteamUtils");
        LOG_TRACE("{} -> 'SteamUtils' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamVR_ComputeDistortion");
        src_address = dlsym(original_lib_handle, "SteamVR_ComputeDistortion");
        LOG_TRACE("{} -> 'SteamVR_ComputeDistortion' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamVR_GetD3D9AdapterIndex");
        src_address = dlsym(original_lib_handle, "SteamVR_GetD3D9AdapterIndex");
        LOG_TRACE("{} -> 'SteamVR_GetD3D9AdapterIndex' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamVR_GetDisplayId");
        src_address = dlsym(original_lib_handle, "SteamVR_GetDisplayId");
        LOG_TRACE("{} -> 'SteamVR_GetDisplayId' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamVR_GetDriverId");
        src_address = dlsym(original_lib_handle, "SteamVR_GetDriverId");
        LOG_TRACE("{} -> 'SteamVR_GetDriverId' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamVR_GetEyeOutputViewport");
        src_address = dlsym(original_lib_handle, "SteamVR_GetEyeOutputViewport");
        LOG_TRACE("{} -> 'SteamVR_GetEyeOutputViewport' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamVR_GetHeadFromEyePose");
        src_address = dlsym(original_lib_handle, "SteamVR_GetHeadFromEyePose");
        LOG_TRACE("{} -> 'SteamVR_GetHeadFromEyePose' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamVR_GetLastTrackerFromHeadPose");
        src_address = dlsym(original_lib_handle, "SteamVR_GetLastTrackerFromHeadPose");
        LOG_TRACE("{} -> 'SteamVR_GetLastTrackerFromHeadPose' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamVR_GetProjectionMatrix");
        src_address = dlsym(original_lib_handle, "SteamVR_GetProjectionMatrix");
        LOG_TRACE("{} -> 'SteamVR_GetProjectionMatrix' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamVR_GetProjectionRaw");
        src_address = dlsym(original_lib_handle, "SteamVR_GetProjectionRaw");
        LOG_TRACE("{} -> 'SteamVR_GetProjectionRaw' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamVR_GetRecommendedRenderTargetSize");
        src_address = dlsym(original_lib_handle, "SteamVR_GetRecommendedRenderTargetSize");
        LOG_TRACE("{} -> 'SteamVR_GetRecommendedRenderTargetSize' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamVR_GetTrackerFromHeadPose");
        src_address = dlsym(original_lib_handle, "SteamVR_GetTrackerFromHeadPose");
        LOG_TRACE("{} -> 'SteamVR_GetTrackerFromHeadPose' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamVR_GetTrackerZeroPose");
        src_address = dlsym(original_lib_handle, "SteamVR_GetTrackerZeroPose");
        LOG_TRACE("{} -> 'SteamVR_GetTrackerZeroPose' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamVR_GetViewMatrix");
        src_address = dlsym(original_lib_handle, "SteamVR_GetViewMatrix");
        LOG_TRACE("{} -> 'SteamVR_GetViewMatrix' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamVR_GetWindowBounds");
        src_address = dlsym(original_lib_handle, "SteamVR_GetWindowBounds");
        LOG_TRACE("{} -> 'SteamVR_GetWindowBounds' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamVR_IHmd_Version");
        src_address = dlsym(original_lib_handle, "SteamVR_IHmd_Version");
        LOG_TRACE("{} -> 'SteamVR_IHmd_Version' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamVR_WillDriftInYaw");
        src_address = dlsym(original_lib_handle, "SteamVR_WillDriftInYaw");
        LOG_TRACE("{} -> 'SteamVR_WillDriftInYaw' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamVR_ZeroTracker");
        src_address = dlsym(original_lib_handle, "SteamVR_ZeroTracker");
        LOG_TRACE("{} -> 'SteamVR_ZeroTracker' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamVideo");
        src_address = dlsym(original_lib_handle, "SteamVideo");
        LOG_TRACE("{} -> 'SteamVideo' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "Steam_GetHSteamUserCurrent");
        src_address = dlsym(original_lib_handle, "Steam_GetHSteamUserCurrent");
        LOG_TRACE("{} -> 'Steam_GetHSteamUserCurrent' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "Steam_RegisterInterfaceFuncs");
        src_address = dlsym(original_lib_handle, "Steam_RegisterInterfaceFuncs");
        LOG_TRACE("{} -> 'Steam_RegisterInterfaceFuncs' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "Steam_RunCallbacks");
        src_address = dlsym(original_lib_handle, "Steam_RunCallbacks");
        LOG_TRACE("{} -> 'Steam_RunCallbacks' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "VR_GetControlPanel");
        src_address = dlsym(original_lib_handle, "VR_GetControlPanel");
        LOG_TRACE("{} -> 'VR_GetControlPanel' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "VR_GetGenericInterface");
        src_address = dlsym(original_lib_handle, "VR_GetGenericInterface");
        LOG_TRACE("{} -> 'VR_GetGenericInterface' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "VR_GetStringForHmdError");
        src_address = dlsym(original_lib_handle, "VR_GetStringForHmdError");
        LOG_TRACE("{} -> 'VR_GetStringForHmdError' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "VR_Init");
        src_address = dlsym(original_lib_handle, "VR_Init");
        LOG_TRACE("{} -> 'VR_Init' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "VR_IsHmdPresent");
        src_address = dlsym(original_lib_handle, "VR_IsHmdPresent");
        LOG_TRACE("{} -> 'VR_IsHmdPresent' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "VR_Shutdown");
        src_address = dlsym(original_lib_handle, "VR_Shutdown");
        LOG_TRACE("{} -> 'VR_Shutdown' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "__gcclibcxx_demangle_callback");
        src_address = dlsym(original_lib_handle, "__gcclibcxx_demangle_callback");
        LOG_TRACE("{} -> '__gcclibcxx_demangle_callback' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "__gxx_personality_v0");
        src_address = dlsym(original_lib_handle, "__gxx_personality_v0");
        LOG_TRACE("{} -> '__gxx_personality_v0' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "__new_handler");
        src_address = dlsym(original_lib_handle, "__new_handler");
        LOG_TRACE("{} -> '__new_handler' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "__wrap___lxstat");
        src_address = dlsym(original_lib_handle, "__wrap___lxstat");
        LOG_TRACE("{} -> '__wrap___lxstat' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "__wrap___lxstat64");
        src_address = dlsym(original_lib_handle, "__wrap___lxstat64");
        LOG_TRACE("{} -> '__wrap___lxstat64' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "__wrap___xstat");
        src_address = dlsym(original_lib_handle, "__wrap___xstat");
        LOG_TRACE("{} -> '__wrap___xstat' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "__wrap___xstat64");
        src_address = dlsym(original_lib_handle, "__wrap___xstat64");
        LOG_TRACE("{} -> '__wrap___xstat64' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "__wrap_access");
        src_address = dlsym(original_lib_handle, "__wrap_access");
        LOG_TRACE("{} -> '__wrap_access' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "__wrap_chdir");
        src_address = dlsym(original_lib_handle, "__wrap_chdir");
        LOG_TRACE("{} -> '__wrap_chdir' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "__wrap_chmod");
        src_address = dlsym(original_lib_handle, "__wrap_chmod");
        LOG_TRACE("{} -> '__wrap_chmod' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "__wrap_chown");
        src_address = dlsym(original_lib_handle, "__wrap_chown");
        LOG_TRACE("{} -> '__wrap_chown' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "__wrap_dlmopen");
        src_address = dlsym(original_lib_handle, "__wrap_dlmopen");
        LOG_TRACE("{} -> '__wrap_dlmopen' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "__wrap_dlopen");
        src_address = dlsym(original_lib_handle, "__wrap_dlopen");
        LOG_TRACE("{} -> '__wrap_dlopen' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "__wrap_fopen");
        src_address = dlsym(original_lib_handle, "__wrap_fopen");
        LOG_TRACE("{} -> '__wrap_fopen' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "__wrap_fopen64");
        src_address = dlsym(original_lib_handle, "__wrap_fopen64");
        LOG_TRACE("{} -> '__wrap_fopen64' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "__wrap_freopen");
        src_address = dlsym(original_lib_handle, "__wrap_freopen");
        LOG_TRACE("{} -> '__wrap_freopen' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "__wrap_lchown");
        src_address = dlsym(original_lib_handle, "__wrap_lchown");
        LOG_TRACE("{} -> '__wrap_lchown' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "__wrap_link");
        src_address = dlsym(original_lib_handle, "__wrap_link");
        LOG_TRACE("{} -> '__wrap_link' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "__wrap_lstat");
        src_address = dlsym(original_lib_handle, "__wrap_lstat");
        LOG_TRACE("{} -> '__wrap_lstat' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "__wrap_lstat64");
        src_address = dlsym(original_lib_handle, "__wrap_lstat64");
        LOG_TRACE("{} -> '__wrap_lstat64' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "__wrap_mkdir");
        src_address = dlsym(original_lib_handle, "__wrap_mkdir");
        LOG_TRACE("{} -> '__wrap_mkdir' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "__wrap_mkfifo");
        src_address = dlsym(original_lib_handle, "__wrap_mkfifo");
        LOG_TRACE("{} -> '__wrap_mkfifo' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "__wrap_mknod");
        src_address = dlsym(original_lib_handle, "__wrap_mknod");
        LOG_TRACE("{} -> '__wrap_mknod' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "__wrap_mount");
        src_address = dlsym(original_lib_handle, "__wrap_mount");
        LOG_TRACE("{} -> '__wrap_mount' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "__wrap_open");
        src_address = dlsym(original_lib_handle, "__wrap_open");
        LOG_TRACE("{} -> '__wrap_open' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "__wrap_open64");
        src_address = dlsym(original_lib_handle, "__wrap_open64");
        LOG_TRACE("{} -> '__wrap_open64' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "__wrap_opendir");
        src_address = dlsym(original_lib_handle, "__wrap_opendir");
        LOG_TRACE("{} -> '__wrap_opendir' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "__wrap_rename");
        src_address = dlsym(original_lib_handle, "__wrap_rename");
        LOG_TRACE("{} -> '__wrap_rename' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "__wrap_rmdir");
        src_address = dlsym(original_lib_handle, "__wrap_rmdir");
        LOG_TRACE("{} -> '__wrap_rmdir' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "__wrap_scandir");
        src_address = dlsym(original_lib_handle, "__wrap_scandir");
        LOG_TRACE("{} -> '__wrap_scandir' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "__wrap_scandir64");
        src_address = dlsym(original_lib_handle, "__wrap_scandir64");
        LOG_TRACE("{} -> '__wrap_scandir64' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "__wrap_stat");
        src_address = dlsym(original_lib_handle, "__wrap_stat");
        LOG_TRACE("{} -> '__wrap_stat' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "__wrap_stat64");
        src_address = dlsym(original_lib_handle, "__wrap_stat64");
        LOG_TRACE("{} -> '__wrap_stat64' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "__wrap_statfs");
        src_address = dlsym(original_lib_handle, "__wrap_statfs");
        LOG_TRACE("{} -> '__wrap_statfs' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "__wrap_statfs64");
        src_address = dlsym(original_lib_handle, "__wrap_statfs64");
        LOG_TRACE("{} -> '__wrap_statfs64' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "__wrap_statvfs");
        src_address = dlsym(original_lib_handle, "__wrap_statvfs");
        LOG_TRACE("{} -> '__wrap_statvfs' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "__wrap_statvfs64");
        src_address = dlsym(original_lib_handle, "__wrap_statvfs64");
        LOG_TRACE("{} -> '__wrap_statvfs64' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "__wrap_symlink");
        src_address = dlsym(original_lib_handle, "__wrap_symlink");
        LOG_TRACE("{} -> '__wrap_symlink' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "__wrap_unlink");
        src_address = dlsym(original_lib_handle, "__wrap_unlink");
        LOG_TRACE("{} -> '__wrap_unlink' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "__wrap_utime");
        src_address = dlsym(original_lib_handle, "__wrap_utime");
        LOG_TRACE("{} -> '__wrap_utime' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "__wrap_utimes");
        src_address = dlsym(original_lib_handle, "__wrap_utimes");
        LOG_TRACE("{} -> '__wrap_utimes' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "g_pSteamClientGameServer");
        src_address = dlsym(original_lib_handle, "g_pSteamClientGameServer");
        LOG_TRACE("{} -> 'g_pSteamClientGameServer' src: {}, dest: {}", __func__, src_address, dest_address);
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 2, &src_address, sizeof(void*));

        initialized = true;
        LOG_INFO("Proxy exports initialized");
    }
}
